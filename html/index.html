<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>YASK: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kernel: a software framework for creating HPC stencil code. Copyright 2014-2018 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">YASK Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction</a><ul><li class="level2"><a href="#yc_intro">Define a Stencil Solution and Generate Kernel Code</a></li>
<li class="level2"><a href="#yk_intro">Create a Stencil Kernel Library and Stencil-based Application</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_yc">YASK Stencil Compiler API</a><ul><li class="level2"><a href="#yc_oview">Compiler Overview</a></li>
<li class="level2"><a href="#yc_usage">Typical Program Flow using the Compiler API</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_yk">YASK Stencil Kernel API</a><ul><li class="level2"><a href="#yk_oview">Kernel Overview</a></li>
<li class="level2"><a href="#yk_usage">Typical Program Flow using the Kernel API</a></li>
</ul>
</li>
<li class="level1"><a href="#sec_tests">Example Tests</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>The typical high-level YASK workflow is as follows:</p><ol type="1">
<li><a class="el" href="index.html#yc_intro">Define a Stencil Solution and Generate Kernel Code</a><ul>
<li>Define a stencil solution using the YASK domain-specific language (DSL).</li>
<li>Use the YASK stencil compiler to generate C++ kernel code from the stencil solution.</li>
</ul>
</li>
<li><a class="el" href="index.html#yk_intro">Create a Stencil Kernel Library and Stencil-based Application</a><ul>
<li>Compile the generated C++ kernel code to create a YASK kernel library.</li>
<li>Create and use a stencil-based application using the kernel library.</li>
</ul>
</li>
<li>Test and deploy your new YASK-enabled application.</li>
</ol>
<p>There are two sets of APIs provided by YASK corresponding to the first two tasks:</p><ol type="1">
<li>The <a class="el" href="index.html#sec_yc">YASK Stencil Compiler API</a> (available in C++ and Python).</li>
<li>The <a class="el" href="index.html#sec_yk">YASK Stencil Kernel API</a> (available in C++ and Python).</li>
</ol>
<p>For each of the tasks, you can either use the YASK-provided application or create your own application built with the corresponding API.</p>
<p>These alternatives may be mixed-or-matched in all combinations. For example, you can use the YASK-provided stencil compiler to generate a YASK kernel library and then use that library via the kernel API to create your own stencil-based Python application.</p>
<p>The following sub-sections describe each of the tasks in the workflow and when the APIs may be used.</p>
<h2><a class="anchor" id="yc_intro"></a>
Define a Stencil Solution and Generate Kernel Code</h2>
<p>A stencil solution consists of the grid variables containing the problem data and one or more equations that describe how grid points are calculated. An equation consists of a grid point to be calculated that "EQUALS" an expression consisting of other grid points, constants, mathematical operators, etc.</p><ul>
<li>Example equation: <code>u(t+1, x, y) EQUALS (u(t, x, y) + u(t, x+1, y) + u(t, x, y+1)) / 3</code>.</li>
</ul>
<p>A new stencil solution may be defined in one of the following ways:</p><ol type="1">
<li>Write a stencil in C++ that will be compiled into the standard YASK stencil compiler, <code>bin/yask_compiler.exe</code>.<ul>
<li>This approach is typically taken when the programmer or scientist wants to express the equations of the stencil directly.</li>
<li>In this case, the equations can be typed exactly as shown in the above example (C++ operator overloading is used automatically to construct an internal representation of each equation).</li>
<li>To generate the kernel code for the defined stencil, [re]compile and run the YASK stencil compiler. This is done automatically when building a YASK kernel using the YASK <code>Makefile</code>, or you can build it explicity via <code>make compiler</code> and run it from your shell command-prompt.</li>
<li>See example stencils in <code>src/stencils</code>. These stencils are written as classes inherited from the <code>StencilBase</code> class.</li>
</ul>
</li>
<li>Use the YASK compiler API to create another application that defines stencils.<ul>
<li>This approach is typically taken when a 3rd-party front-end tool will be creating stencils from another, possibly higher-level, description, e.g., applying finite-difference methods to differential equations.</li>
<li>In this case, the equations are built up programmatically into an abstract syntax tree (AST).</li>
<li>The mechanism to generate the kernel code in this approach depends on the application created from the APIs. The application might be run from a command-prompt, or the user might control it interactively.</li>
<li>See <code>src/compiler/tests/yask_compiler_api_test.cpp</code> for an example stencil definition in C++.</li>
<li>See <code>bin/yask_compiler_api_test.py</code> for an example stencil definition in Python.</li>
<li>See <a class="el" href="index.html#sec_yc">YASK Stencil Compiler API</a> for documentation on the compiler API.</li>
</ul>
</li>
</ol>
<p>In either case, the resulting generated code should written to the C++ stencil-code file, <code>src/kernel/gen/yask_stencil_code.hpp</code>.</p>
<h2><a class="anchor" id="yk_intro"></a>
Create a Stencil Kernel Library and Stencil-based Application</h2>
<p>Once the stencil-code file is created, it must be compiled into a YASK kernel library.</p><ul>
<li>There will be a separate library created for each stencil solution and target architecture combination.</li>
<li>This is done automatically when building a YASK kernel using the YASK <code>Makefile</code>, e.g., via <code>make -j stencil=iso3dfd arch=knl</code>, which builds the "iso3dfd" stencil for the Intel Xeon Phi processor.</li>
<li>If you generated the stencil-code file via another means (e.g., by running the compiler manually or using a program using the compiler API), you may still create a kernel library using the <code>Makefile</code>; you'll just need to use the special target <code>kernel-only</code> to avoid running the compiler. You'll also still need to specify the target architecture and give a descriptive name to the stencil. Example: <code>make stencil=my-stencil arch=hsw kernel-only</code>.</li>
</ul>
<p>If <code>make</code> is invoked as in one of the above examples, it will create the kernel library in <code>lib/libyask_kernel.</code><em>stencil.arch</em><code>.so</code>, where <em>stencil</em> and <em>arch</em> match the corresponding variables provided during <code>make</code>.</p>
<p>To use the kernel library, an executable must be created from it. This may be done in one of the following ways:</p><ol type="1">
<li>The default YASK kernel executable will automatically be created in <code>bin/yask_kernel.</code><em>stencil.arch</em><code>.exe</code> when <code>make</code> is invoked as in the above examples.<ul>
<li>This application may be run via <code>bin/yask.sh</code> to obtain a performance measurement of the kernel.</li>
</ul>
</li>
<li>You can also create your own stencil application using the YASK stencil kernel API.<ul>
<li>This approach would be taken to integrate the kernel into a larger application that would inject real-world initial-state data into the grids and extract the final-state data for analysis or further processing.</li>
<li>See <code>src/kernel/tests/yask_kernel_api_test.cpp</code> for an example kernel usage in C++.</li>
<li>See <code>bin/yask_kernel_api_test.py</code> for an example kernel usage in Python.</li>
<li>See <a class="el" href="index.html#sec_yk">YASK Stencil Kernel API</a> for documentation on the kernel API.</li>
</ul>
</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Anytime you want to change the name or any compile-time properties of the kernel, be sure to run <code>make clean</code> to force the removal of all kernel-specific intermediate code. Otherwise, you will likely see some unexpected errors when building the new kernel.</dd></dl>
<h1><a class="anchor" id="sec_yc"></a>
YASK Stencil Compiler API</h1>
<h2><a class="anchor" id="yc_oview"></a>
Compiler Overview</h2>
<p>This section provides usage information for the YASK stencil compiler API (application-programmer interface).<br />
The API is available for C++ and for Python via SWIG. Type names are prefixed with 'yc_' to indicate "YASK compiler"; this distinguishes them from the 'yk_'-prefixed types used in the "YASK kernel" API.</p>
<p>The types, classes, and functions are listed in <a class="el" href="group__yc.html">YASK Compiler</a>.</p>
<h2><a class="anchor" id="yc_usage"></a>
Typical Program Flow using the Compiler API</h2>
<ul>
<li>Create a <a class="el" href="classyask_1_1yc__factory.html" title="Bootstrap factory to create objects needed to define a stencil solution. ">yc_factory</a>. This is the "bootstrap" object that will be used to create others.</li>
<li>Create a <a class="el" href="classyask_1_1yc__solution.html" title="Stencil solution. ">yc_solution</a> object via <a class="el" href="classyask_1_1yc__factory.html#a9daa1244d0eae15b85c3c8161f367f11" title="Create a stencil solution. ">yc_factory::new_solution()</a>.</li>
<li>Create one or more <a class="el" href="classyask_1_1yc__grid.html">yc_grid</a> objects via <a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802" title="Create an n-dimensional grid variable in the solution. ">yc_solution::new_grid()</a> as needed by the stencil(s) being implemented. Calls to <a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802" title="Create an n-dimensional grid variable in the solution. ">yc_solution::new_grid()</a> specify the name and dimensions of each grid. Grids may be read-only (constants) or read-write. Each grid will be a part of the solution from which it was created.</li>
<li>Create an equation for each read-write grid.<ul>
<li>Create expressions "bottom-up" by creating the leaf nodes first.</li>
<li>Leaf nodes may be floating-point (FP) constants or references to grid points.</li>
<li>Constants are created via <a class="el" href="classyask_1_1yc__node__factory.html#ad2fda22e63ea36d777d550a805642a8e" title="Create a constant numerical value node. ">yc_node_factory::new_const_number_node()</a>.</li>
<li>References to grid points are created via <a class="el" href="classyask_1_1yc__grid.html#a93655a64fc56493102db3f570222ad60" title="Create a reference to a point in a grid using relative offsets. ">yc_grid::new_relative_grid_point()</a>, which specifies the grid indices relative to any point within the grid domain.</li>
<li>Create operator nodes via calls to <a class="el" href="classyask_1_1yc__node__factory.html#ac3454548f9f88b9ca7ac49723155864c" title="Create an addition node. ">yc_node_factory::new_add_node()</a>, etc., to build up larger expressions.</li>
<li>To complete each equation, use <a class="el" href="classyask_1_1yc__node__factory.html#a1da71b89d7fe25beeb044eb61f9efe0c" title="Create an equation node. ">yc_node_factory::new_equation_node()</a> to specify an expression on the right-hand side (RHS) and the grid point that is defined to be equal to it on the left-hand side (LHS).</li>
<li>Specify the solution domain dimension via <a class="el" href="classyask_1_1yc__node__factory.html#a7c47726eb7de2b9cd174cfcff7745699" title="Create a domain-index node. ">yc_node_factory::new_domain_index()</a>.</li>
<li>Specify the solution step dimension via <a class="el" href="classyask_1_1yc__node__factory.html#a5c92535a08258803f35bdacb31fc4682" title="Create a step-index node. ">yc_node_factory::new_step_index()</a>. (This is usually "t" for time.)</li>
</ul>
</li>
<li>Specify the number of bytes in a floating-point element via <a class="el" href="classyask_1_1yc__solution.html#a6ce565febd97f50efae59c37d7d5ef4f" title="Set floating-point precision. ">yc_solution::set_element_bytes()</a>. This should be 4 or 8.</li>
<li>Optionally specify the vector-folding and/or vector-clustering via <a class="el" href="classyask_1_1yc__solution.html#a1168b5b8044e39c047d81a5fe5efc06e" title="Set the vectorization length in given dimension. ">yc_solution::set_fold_len()</a> and/or <a class="el" href="classyask_1_1yc__solution.html#a45cb1df4af6886e82f98904473873272" title="Set the cluster multiplier (unroll factor) in given dimension. ">yc_solution::set_cluster_mult()</a>.</li>
<li>Format the equations for additional processing via <a class="el" href="classyask_1_1yc__solution.html#aa1e606a7a3a3d3fee9d5758095065fd2" title="Format the current equation(s) and write to given output object. ">yc_solution::format()</a>.</li>
</ul>
<h1><a class="anchor" id="sec_yk"></a>
YASK Stencil Kernel API</h1>
<h2><a class="anchor" id="yk_oview"></a>
Kernel Overview</h2>
<p>This section provides usage information for the YASK stencil kernel API (application-programmer interface).<br />
The API is available for C++ and for Python via SWIG. Type names are prefixed with 'yk_' to indicate "YASK kernel"; this distinguishes them from the 'yc_'-prefixed types used in the "YASK compiler" API.</p>
<p>The types, classes, and functions are listed in <a class="el" href="group__yk.html">YASK Kernel</a>.</p>
<h2><a class="anchor" id="yk_usage"></a>
Typical Program Flow using the Kernel API</h2>
<ul>
<li>Create a <a class="el" href="classyask_1_1yk__factory.html">yk_factory</a>. This is the "bootstrap" object that will be used to create others.</li>
<li>Create a <a class="el" href="classyask_1_1yk__env.html">yk_env</a> object via <a class="el" href="classyask_1_1yk__factory.html#a7eed1ca2e79b5edb76f2cafb57cad459" title="Create an object to hold environment information. ">yk_factory::new_env()</a>. This initializes MPI if you have enabled it.</li>
<li>Create a <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> object via <a class="el" href="classyask_1_1yk__factory.html#ab882536b5dc6c9c5142aede57fd83155" title="Create a stencil solution. ">yk_factory::new_solution()</a>. A pointer to the environment object is provided. This structure allows you to initialize MPI early in the program. The solution contains the grids and equations defined by the stencil compiler process.</li>
<li>Use the <a class="el" href="classyask_1_1yk__solution.html">yk_solution</a> methods to configure options like the size of the problem domain.</li>
<li>Set up internal data structures via <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a>. This adjusts any settings as needed, determines each rank's position in the problem if MPI is enabled, and allocates data for the grids. Be sure to modify any settings before calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a>.</li>
<li>Access the solution grids via <a class="el" href="classyask_1_1yk__solution.html#af882342252120bf3b7236d0be99ffbe0" title="Get the specified grid. ">yk_solution::get_grid()</a>. Various properties of each grid may be retrieved or set. In particular, you should initialize the data in each grid via <a class="el" href="classyask_1_1yk__grid.html#a9f45864a94cad82e0b54df6a2cc95301" title="Initialize all grid elements to the same value. ">yk_grid::set_all_elements_same()</a> and <a class="el" href="classyask_1_1yk__grid.html#a9f93ff6dc86a5161a9a5b642e8a82698" title="Set the value of one element in this grid. ">yk_grid::set_element()</a>.</li>
<li>Apply the stencil(s) to the grids via <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">yk_solution::run_solution()</a>. There are versions for advancing one or more steps.</li>
<li>Retrieve the final results via <a class="el" href="classyask_1_1yk__grid.html#ad8883712389516498e62add0f77bd631" title="Read the value of one element in this grid. ">yk_grid::get_element()</a>.</li>
</ul>
<h1><a class="anchor" id="sec_tests"></a>
Example Tests</h1>
<p>The following examples illustrate possible combinations of compilers and kernels.</p><ul>
<li>You can add <code>stencil=</code>_stencil-name_ to use a specific stencil for testing.</li>
<li>You can add <code>arch=</code>_arch-name_ to target one of the architectures listed in the <code>Makefile</code> if desired.</li>
<li>Run <code>make clean</code> before all of the example commands to ensure consistent builds.</li>
</ul>
<table class="doxtable">
<tr>
<th>Stencil Compiler </th><th>Stencil Application </th><th>Test Command  </th></tr>
<tr>
<td>YASK-provided </td><td>YASK-provided </td><td><code>make -j yc-and-yk-test</code> </td></tr>
<tr>
<td>YASK-provided </td><td>C++ test example </td><td><code>make -j yc-and-cxx-yk-api-test</code> </td></tr>
<tr>
<td>YASK-provided </td><td>Python test example </td><td><code>make -j yc-and-py-yk-api-test</code> </td></tr>
<tr>
<td>C++ test example </td><td>YASK-provided </td><td><code>make -j cxx-yc-api-and-yk-test</code> </td></tr>
<tr>
<td>C++ test example </td><td>C++ test example </td><td><code>make -j cxx-yc-api-and-cxx-yk-api-test</code> </td></tr>
<tr>
<td>C++ test example </td><td>Python test example </td><td><code>make -j cxx-yc-api-and-py-yk-api-test</code> </td></tr>
<tr>
<td>Python test example </td><td>YASK-provided </td><td><code>make -j py-yc-api-and-yk-test</code> </td></tr>
<tr>
<td>Python test example </td><td>C++ test example </td><td><code>make -j py-yc-api-and-cxx-yk-api-test</code> </td></tr>
<tr>
<td>Python test example </td><td>Python test example </td><td><code>make -j py-yc-api-and-py-yk-api-test</code> </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
