<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>YASK: yask::yk_solution Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kernel: a software framework for creating HPC stencil code. Copyright 2014-2018 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yask</b></li><li class="navelem"><a class="el" href="classyask_1_1yk__solution.html">yk_solution</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyask_1_1yk__solution-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yask::yk_solution Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__yk.html">YASK Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Stencil solution as defined by the generated code from the YASK stencil compiler.  
 <a href="classyask_1_1yk__solution.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="yk__solution__api_8hpp_source.html">yk_solution_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa315469b5836e531425836f4fc5eff1c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#aa315469b5836e531425836f4fc5eff1c">set_debug_output</a> (<a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a> debug)=0</td></tr>
<tr class="memdesc:aa315469b5836e531425836f4fc5eff1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set object to receive debug output.  <a href="#aa315469b5836e531425836f4fc5eff1c">More...</a><br /></td></tr>
<tr class="separator:aa315469b5836e531425836f4fc5eff1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54560fd93ebb2361a0f887a29b68727a"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a54560fd93ebb2361a0f887a29b68727a">get_name</a> () const  =0</td></tr>
<tr class="memdesc:a54560fd93ebb2361a0f887a29b68727a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the solution.  <a href="#a54560fd93ebb2361a0f887a29b68727a">More...</a><br /></td></tr>
<tr class="separator:a54560fd93ebb2361a0f887a29b68727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0097b91ea92fbe781ba4e8b6746bd665"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665">get_element_bytes</a> () const  =0</td></tr>
<tr class="memdesc:a0097b91ea92fbe781ba4e8b6746bd665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the floating-point precision size.  <a href="#a0097b91ea92fbe781ba4e8b6746bd665">More...</a><br /></td></tr>
<tr class="separator:a0097b91ea92fbe781ba4e8b6746bd665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8447a472034f4c9db2238dc18a50109"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ad8447a472034f4c9db2238dc18a50109">get_step_dim_name</a> () const  =0</td></tr>
<tr class="memdesc:ad8447a472034f4c9db2238dc18a50109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the solution step dimension.  <a href="#ad8447a472034f4c9db2238dc18a50109">More...</a><br /></td></tr>
<tr class="separator:ad8447a472034f4c9db2238dc18a50109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd322aa43ca790c31cc31c2bbd59368"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a9bd322aa43ca790c31cc31c2bbd59368">get_num_domain_dims</a> () const  =0</td></tr>
<tr class="memdesc:a9bd322aa43ca790c31cc31c2bbd59368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of domain dimensions used in this solution.  <a href="#a9bd322aa43ca790c31cc31c2bbd59368">More...</a><br /></td></tr>
<tr class="separator:a9bd322aa43ca790c31cc31c2bbd59368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163d10690a6b636b2929e9a82ac2737b"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b">get_domain_dim_names</a> () const  =0</td></tr>
<tr class="memdesc:a163d10690a6b636b2929e9a82ac2737b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the domain dimension names.  <a href="#a163d10690a6b636b2929e9a82ac2737b">More...</a><br /></td></tr>
<tr class="separator:a163d10690a6b636b2929e9a82ac2737b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef99aeda1db20563066c00a66533fbc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#adef99aeda1db20563066c00a66533fbc">get_misc_dim_names</a> () const  =0</td></tr>
<tr class="memdesc:adef99aeda1db20563066c00a66533fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the miscellaneous dimension names.  <a href="#adef99aeda1db20563066c00a66533fbc">More...</a><br /></td></tr>
<tr class="separator:adef99aeda1db20563066c00a66533fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155d8f4a38da9da11488a18cca50bae8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8">set_rank_domain_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a155d8f4a38da9da11488a18cca50bae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the solution domain for this rank.  <a href="#a155d8f4a38da9da11488a18cca50bae8">More...</a><br /></td></tr>
<tr class="separator:a155d8f4a38da9da11488a18cca50bae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1973cf0d0c10c12f01534fb41535586e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a1973cf0d0c10c12f01534fb41535586e">get_rank_domain_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a1973cf0d0c10c12f01534fb41535586e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the domain size for this rank.  <a href="#a1973cf0d0c10c12f01534fb41535586e">More...</a><br /></td></tr>
<tr class="separator:a1973cf0d0c10c12f01534fb41535586e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3c7317bf1b397f332962d658f38839"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839">set_block_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:abd3c7317bf1b397f332962d658f38839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the block size in the given dimension.  <a href="#abd3c7317bf1b397f332962d658f38839">More...</a><br /></td></tr>
<tr class="separator:abd3c7317bf1b397f332962d658f38839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c8cffa851a17036334f3259477718e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a01c8cffa851a17036334f3259477718e">get_block_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a01c8cffa851a17036334f3259477718e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the block size.  <a href="#a01c8cffa851a17036334f3259477718e">More...</a><br /></td></tr>
<tr class="separator:a01c8cffa851a17036334f3259477718e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cd27d412b6fe013db58b167999a362"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac4cd27d412b6fe013db58b167999a362">set_num_ranks</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> num)=0</td></tr>
<tr class="memdesc:ac4cd27d412b6fe013db58b167999a362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of MPI ranks in the given dimension.  <a href="#ac4cd27d412b6fe013db58b167999a362">More...</a><br /></td></tr>
<tr class="separator:ac4cd27d412b6fe013db58b167999a362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749f383c04f922fbc8fa603164760bba"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a749f383c04f922fbc8fa603164760bba">get_num_ranks</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a749f383c04f922fbc8fa603164760bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of MPI ranks in the given dimension.  <a href="#a749f383c04f922fbc8fa603164760bba">More...</a><br /></td></tr>
<tr class="separator:a749f383c04f922fbc8fa603164760bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3074305ff8b70c3a8171f22a609082"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a0d3074305ff8b70c3a8171f22a609082">get_rank_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a0d3074305ff8b70c3a8171f22a609082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank index in the specified dimension.  <a href="#a0d3074305ff8b70c3a8171f22a609082">More...</a><br /></td></tr>
<tr class="separator:a0d3074305ff8b70c3a8171f22a609082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907d04284cb2f95af409088f4a35aef4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a907d04284cb2f95af409088f4a35aef4">get_num_grids</a> () const  =0</td></tr>
<tr class="memdesc:a907d04284cb2f95af409088f4a35aef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of grids in the solution.  <a href="#a907d04284cb2f95af409088f4a35aef4">More...</a><br /></td></tr>
<tr class="separator:a907d04284cb2f95af409088f4a35aef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af882342252120bf3b7236d0be99ffbe0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#af882342252120bf3b7236d0be99ffbe0">get_grid</a> (const std::string &amp;name)=0</td></tr>
<tr class="memdesc:af882342252120bf3b7236d0be99ffbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified grid.  <a href="#af882342252120bf3b7236d0be99ffbe0">More...</a><br /></td></tr>
<tr class="separator:af882342252120bf3b7236d0be99ffbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92ef451e38e83c462d5c3383476f28f"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#af92ef451e38e83c462d5c3383476f28f">get_grids</a> ()=0</td></tr>
<tr class="memdesc:af92ef451e38e83c462d5c3383476f28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the grids.  <a href="#af92ef451e38e83c462d5c3383476f28f">More...</a><br /></td></tr>
<tr class="separator:af92ef451e38e83c462d5c3383476f28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0edfde033c251e3f8d2d184a682d4cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb">prepare_solution</a> ()=0</td></tr>
<tr class="memdesc:aa0edfde033c251e3f8d2d184a682d4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare the solution for stencil application.  <a href="#aa0edfde033c251e3f8d2d184a682d4cb">More...</a><br /></td></tr>
<tr class="separator:aa0edfde033c251e3f8d2d184a682d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d9a4c12c5fb5111dfc1382e724f3cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ad7d9a4c12c5fb5111dfc1382e724f3cc">get_first_rank_domain_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:ad7d9a4c12c5fb5111dfc1382e724f3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of the sub-domain in this rank in the specified dimension.  <a href="#ad7d9a4c12c5fb5111dfc1382e724f3cc">More...</a><br /></td></tr>
<tr class="separator:ad7d9a4c12c5fb5111dfc1382e724f3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d5546559dc281e9c588478cb65b1c8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#af2d5546559dc281e9c588478cb65b1c8">get_last_rank_domain_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:af2d5546559dc281e9c588478cb65b1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of the sub-domain in this rank the specified dimension.  <a href="#af2d5546559dc281e9c588478cb65b1c8">More...</a><br /></td></tr>
<tr class="separator:af2d5546559dc281e9c588478cb65b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cfc055104248132c4a59e1e08d5fe9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a10cfc055104248132c4a59e1e08d5fe9">get_overall_domain_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a10cfc055104248132c4a59e1e08d5fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overall problem size in the specified dimension.  <a href="#a10cfc055104248132c4a59e1e08d5fe9">More...</a><br /></td></tr>
<tr class="separator:a10cfc055104248132c4a59e1e08d5fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cc5625fc524fe8eb8d3cedc66778aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa">run_solution</a> (<a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> first_step_index, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> last_step_index)=0</td></tr>
<tr class="memdesc:a14cc5625fc524fe8eb8d3cedc66778aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the stencil solution for the specified steps.  <a href="#a14cc5625fc524fe8eb8d3cedc66778aa">More...</a><br /></td></tr>
<tr class="separator:a14cc5625fc524fe8eb8d3cedc66778aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46dc15b38732b30c820ffd7765292342"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a46dc15b38732b30c820ffd7765292342">run_solution</a> (<a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> step_index)=0</td></tr>
<tr class="memdesc:a46dc15b38732b30c820ffd7765292342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the stencil solution for the specified step.  <a href="#a46dc15b38732b30c820ffd7765292342">More...</a><br /></td></tr>
<tr class="separator:a46dc15b38732b30c820ffd7765292342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac6a33fe5d098d31a844f4eba654b19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#afac6a33fe5d098d31a844f4eba654b19">end_solution</a> ()=0</td></tr>
<tr class="memdesc:afac6a33fe5d098d31a844f4eba654b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish using a solution.  <a href="#afac6a33fe5d098d31a844f4eba654b19">More...</a><br /></td></tr>
<tr class="separator:afac6a33fe5d098d31a844f4eba654b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2755703f0d90aa4e3ef36093a1976f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#ga12d1d46aeb01bd7509a8dc3251657f75">yk_stats_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ab2755703f0d90aa4e3ef36093a1976f5">get_stats</a> ()=0</td></tr>
<tr class="memdesc:ab2755703f0d90aa4e3ef36093a1976f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get performance statistics associated with preceding calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">run_solution()</a>.  <a href="#ab2755703f0d90aa4e3ef36093a1976f5">More...</a><br /></td></tr>
<tr class="separator:ab2755703f0d90aa4e3ef36093a1976f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150bb5f7d351afd9b64744f32fea4f5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a150bb5f7d351afd9b64744f32fea4f5c">is_auto_tuner_enabled</a> () const  =0</td></tr>
<tr class="memdesc:a150bb5f7d351afd9b64744f32fea4f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the auto-tuner is enabled on this rank.  <a href="#a150bb5f7d351afd9b64744f32fea4f5c">More...</a><br /></td></tr>
<tr class="separator:a150bb5f7d351afd9b64744f32fea4f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923afb4530ef5f0370f8bf55856fa040"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a923afb4530ef5f0370f8bf55856fa040">set_region_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a923afb4530ef5f0370f8bf55856fa040"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the region size in the given dimension.  <a href="#a923afb4530ef5f0370f8bf55856fa040">More...</a><br /></td></tr>
<tr class="separator:a923afb4530ef5f0370f8bf55856fa040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabb070ab8e0afbceb1db9a9a020c54e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#acabb070ab8e0afbceb1db9a9a020c54e">get_region_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:acabb070ab8e0afbceb1db9a9a020c54e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the region size.  <a href="#acabb070ab8e0afbceb1db9a9a020c54e">More...</a><br /></td></tr>
<tr class="separator:acabb070ab8e0afbceb1db9a9a020c54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bd7e95ea13631954d92a638badfb2d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d">set_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:ab3bd7e95ea13631954d92a638badfb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum amount of grid padding for all grids.  <a href="#ab3bd7e95ea13631954d92a638badfb2d">More...</a><br /></td></tr>
<tr class="separator:ab3bd7e95ea13631954d92a638badfb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad245bacafc9fe7c91a29fe677b43526b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ad245bacafc9fe7c91a29fe677b43526b">get_min_pad_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:ad245bacafc9fe7c91a29fe677b43526b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the minimum amount of grid padding for all grids.  <a href="#ad245bacafc9fe7c91a29fe677b43526b">More...</a><br /></td></tr>
<tr class="separator:ad245bacafc9fe7c91a29fe677b43526b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932fad2ede1aecef168189c0aa972b0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a932fad2ede1aecef168189c0aa972b0b">reset_auto_tuner</a> (bool enable, bool verbose=false)=0</td></tr>
<tr class="memdesc:a932fad2ede1aecef168189c0aa972b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Restart or disable the auto-tuner on this rank.  <a href="#a932fad2ede1aecef168189c0aa972b0b">More...</a><br /></td></tr>
<tr class="separator:a932fad2ede1aecef168189c0aa972b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e92afeb1d201ea0174fa04029ec0077"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a8e92afeb1d201ea0174fa04029ec0077">run_auto_tuner_now</a> (bool verbose=true)=0</td></tr>
<tr class="memdesc:a8e92afeb1d201ea0174fa04029ec0077"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Automatically tune selected settings immediately.  <a href="#a8e92afeb1d201ea0174fa04029ec0077">More...</a><br /></td></tr>
<tr class="separator:a8e92afeb1d201ea0174fa04029ec0077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40302135611353f57b626d4ff55af25"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25">new_grid</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:ac40302135611353f57b626d4ff55af25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new grid to the solution.  <a href="#ac40302135611353f57b626d4ff55af25">More...</a><br /></td></tr>
<tr class="separator:ac40302135611353f57b626d4ff55af25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdf2fd4c36bc96a5f89ab536c35f586"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#accdf2fd4c36bc96a5f89ab536c35f586">new_grid</a> (const std::string &amp;name, const std::initializer_list&lt; std::string &gt; &amp;dims)=0</td></tr>
<tr class="memdesc:accdf2fd4c36bc96a5f89ab536c35f586"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new grid to the solution.  <a href="#accdf2fd4c36bc96a5f89ab536c35f586">More...</a><br /></td></tr>
<tr class="separator:accdf2fd4c36bc96a5f89ab536c35f586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe399771481546ab7f323c2f3f3984c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c">new_fixed_size_grid</a> (const std::string &amp;name, const std::vector&lt; std::string &gt; &amp;dims, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;dim_sizes)=0</td></tr>
<tr class="memdesc:adbe399771481546ab7f323c2f3f3984c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new grid to the solution with a specified size.  <a href="#adbe399771481546ab7f323c2f3f3984c">More...</a><br /></td></tr>
<tr class="separator:adbe399771481546ab7f323c2f3f3984c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9313f45c164a5feb17502ed70e5b6d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a6f9313f45c164a5feb17502ed70e5b6d">new_fixed_size_grid</a> (const std::string &amp;name, const std::initializer_list&lt; std::string &gt; &amp;dims, const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;dim_sizes)=0</td></tr>
<tr class="memdesc:a6f9313f45c164a5feb17502ed70e5b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Add a new grid to the solution with a specified size.  <a href="#a6f9313f45c164a5feb17502ed70e5b6d">More...</a><br /></td></tr>
<tr class="separator:a6f9313f45c164a5feb17502ed70e5b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bde8dfc73219cec84ad3033faabb90"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac8bde8dfc73219cec84ad3033faabb90">set_default_numa_preferred</a> (int numa_node)=0</td></tr>
<tr class="memdesc:ac8bde8dfc73219cec84ad3033faabb90"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data.  <a href="#ac8bde8dfc73219cec84ad3033faabb90">More...</a><br /></td></tr>
<tr class="separator:ac8bde8dfc73219cec84ad3033faabb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea7c2dd016ce778f9eea0d3a3c87617"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#a6ea7c2dd016ce778f9eea0d3a3c87617">get_default_numa_preferred</a> () const  =0</td></tr>
<tr class="memdesc:a6ea7c2dd016ce778f9eea0d3a3c87617"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data.  <a href="#a6ea7c2dd016ce778f9eea0d3a3c87617">More...</a><br /></td></tr>
<tr class="separator:a6ea7c2dd016ce778f9eea0d3a3c87617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac111abbade055c4923cd0044360ec3b7"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#ac111abbade055c4923cd0044360ec3b7">apply_command_line_options</a> (const std::string &amp;args)=0</td></tr>
<tr class="memdesc:ac111abbade055c4923cd0044360ec3b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set performance parameters from an option string.  <a href="#ac111abbade055c4923cd0044360ec3b7">More...</a><br /></td></tr>
<tr class="separator:ac111abbade055c4923cd0044360ec3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd78008f0b70b509f8dfa94536f63a70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__solution.html#acd78008f0b70b509f8dfa94536f63a70">share_grid_storage</a> (<a class="el" href="group__yk.html#ga2debaa7135bb46dfc295ca623bee2876">yk_solution_ptr</a> source)=0</td></tr>
<tr class="memdesc:acd78008f0b70b509f8dfa94536f63a70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Use data-storage from existing grids in specified solution.  <a href="#acd78008f0b70b509f8dfa94536f63a70">More...</a><br /></td></tr>
<tr class="separator:acd78008f0b70b509f8dfa94536f63a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Stencil solution as defined by the generated code from the YASK stencil compiler. </p>
<p>Objects of this type contain all the grids and equations that comprise a solution. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa315469b5836e531425836f4fc5eff1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_debug_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga605185252a3f3f917593c83b7dde4b66">yask_output_ptr</a>&#160;</td>
          <td class="paramname"><em>debug</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set object to receive debug output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">debug</td><td>Pointer to object to receive debug output. See <a class="el" href="classyask_1_1yask__output__factory.html">yask_output_factory</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a54560fd93ebb2361a0f887a29b68727a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; yask::yk_solution::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the solution. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the solution name provided during stencil compilation. </dd></dl>

</div>
</div>
<a class="anchor" id="a0097b91ea92fbe781ba4e8b6746bd665"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_element_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the floating-point precision size. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in each FP element: 4 or 8. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8447a472034f4c9db2238dc18a50109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_solution::get_step_dim_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the solution step dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing the step-dimension name that was defined by <a class="el" href="classyask_1_1yc__node__factory.html#a5c92535a08258803f35bdacb31fc4682" title="Create a step-index node. ">yc_node_factory::new_step_index()</a> and used in one or more grids. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bd322aa43ca790c31cc31c2bbd59368"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_num_domain_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of domain dimensions used in this solution. </p>
<p>The domain dimensions are those over which the stencil is applied in each step. Does <em>not</em> include the step dimension or any miscellaneous dimensions. </p><dl class="section return"><dt>Returns</dt><dd>Number of dimensions that define the problem domain. </dd></dl>

</div>
</div>
<a class="anchor" id="a163d10690a6b636b2929e9a82ac2737b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; yask::yk_solution::get_domain_dim_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the domain dimension names. </p>
<dl class="section return"><dt>Returns</dt><dd>List of all domain-dimension names that were defined by <a class="el" href="classyask_1_1yc__node__factory.html#a7c47726eb7de2b9cd174cfcff7745699" title="Create a domain-index node. ">yc_node_factory::new_domain_index()</a> and used in one or more grids. </dd></dl>

</div>
</div>
<a class="anchor" id="adef99aeda1db20563066c00a66533fbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; yask::yk_solution::get_misc_dim_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the miscellaneous dimension names. </p>
<dl class="section return"><dt>Returns</dt><dd>List of all dimension names that were either Defined by <a class="el" href="classyask_1_1yc__node__factory.html#a8d1db4e2ced1916ea0e362dd8030fae8" title="Create a new miscellaneous index. ">yc_node_factory::new_misc_index()</a> and used in one or more grids, or Created at run-time by adding a new dimension via <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">yk_solution::new_grid()</a> or <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">yk_solution::new_fixed_size_grid()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a155d8f4a38da9da11488a18cca50bae8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_rank_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the solution domain for this rank. </p>
<p>The domain defines the number of elements that will be evaluated with the stencil(s). If MPI is not enabled, this is the entire problem domain. If MPI is enabled, this is the domain for the current rank only, and the problem domain consists of the sum of all rank domains in each dimension (weak-scaling). The domain size in each rank does not have to be the same, but all domains in the same column must have the same width, all domains in the same row must have the same height, and so forth, for each domain dimension. The domain size does <em>not</em> include the halo area or any padding. For best performance, set the rank domain size to a multiple of the number of elements in a vector-cluster in each dimension whenever possible. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a> for more information on grid sizes. There is no domain-size setting allowed in the solution-step dimension (usually "t"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in the domain in this <code>dim</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1973cf0d0c10c12f01534fb41535586e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_rank_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the domain size for this rank. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of rank domain size in specified dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd3c7317bf1b397f332962d658f38839"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_block_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the block size in the given dimension. </p>
<p>This sets the approximate number of elements that are evaluated in each "block". This is a performance setting and should not affect the functional correctness or total number of elements evaluated. A block is typically the unit of work done by a top-level OpenMP thread. The actual number of elements evaluated in a block may be greater than the specified size due to rounding up to fold-cluster sizes. The number of elements in a block may also be smaller than the specified size when the block is at the edge of the domain. The block size cannot be set in the solution-step dimension (because temporal blocking is not yet enabled).</p>
<p>Unless auto-tuning is disabled, the block size will be used as a starting point for an automated search for a higher-performing block size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in a block in this <code>dim</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01c8cffa851a17036334f3259477718e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_block_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the block size. </p>
<p>Returned value may be slightly larger than the value provided via <a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839" title="Set the block size in the given dimension. ">set_block_size()</a> due to rounding. </p><dl class="section return"><dt>Returns</dt><dd>Current settings of block size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4cd27d412b6fe013db58b167999a362"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_num_ranks </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the number of MPI ranks in the given dimension. </p>
<p>The <em>product</em> of the number of ranks across all dimensions must equal <a class="el" href="classyask_1_1yk__env.html#af58a148c4391d15701c514429441167d" title="Get number of MPI ranks. ">yk_env::get_num_ranks()</a>. The curent MPI rank will be assigned a unique location within the overall problem domain based on its MPI rank index. The same number of MPI ranks must be set via this API on each constituent MPI rank to ensure a consistent overall configuration. The number of ranks in each dimension must be properly set before calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a>. There is no rank setting allowed in the solution-step dimension (usually "t"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of ranks in <code>dim</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a749f383c04f922fbc8fa603164760bba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_num_ranks </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of MPI ranks in the given dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of rank size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d3074305ff8b70c3a8171f22a609082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_rank_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the rank index in the specified dimension. </p>
<p>The overall rank indices in the specified dimension will range from zero (0) to <a class="el" href="classyask_1_1yk__solution.html#a749f383c04f922fbc8fa603164760bba" title="Get the number of MPI ranks in the given dimension. ">get_num_ranks()</a> - 1, inclusive. </p><dl class="section return"><dt>Returns</dt><dd>Zero-based index of this rank. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a907d04284cb2f95af409088f4a35aef4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_num_grids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of grids in the solution. </p>
<p>Grids may be pre-defined by the stencil compiler (e.g., via <a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802" title="Create an n-dimensional grid variable in the solution. ">yc_solution::new_grid()</a>) or created explicitly via <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">yk_solution::new_grid()</a> or <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">yk_solution::new_fixed_size_grid()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Number of grids that have been created. </dd></dl>

</div>
</div>
<a class="anchor" id="af882342252120bf3b7236d0be99ffbe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> yask::yk_solution::get_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the specified grid. </p>
<p>This cannot be used to access scratch grids. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the specified grid or null pointer if it does not exist. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af92ef451e38e83c462d5c3383476f28f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&gt; yask::yk_solution::get_grids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the grids. </p>
<dl class="section return"><dt>Returns</dt><dd>List of all non-scratch grids in the solution. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0edfde033c251e3f8d2d184a682d4cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::prepare_solution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare the solution for stencil application. </p>
<p>Allocates data in grids that do not already have storage allocated. Calculates the position of each rank in the overall problem domain. Sets many other data structures needed for proper stencil application. Since this function initiates MPI communication, it must be called on all MPI ranks, and it will block until all ranks have completed. Must be called before applying any stencils. </p>

</div>
</div>
<a class="anchor" id="ad7d9a4c12c5fb5111dfc1382e724f3cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_first_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of the sub-domain in this rank in the specified dimension. </p>
<p>This returns the first <em>overall</em> index at the beginning of the domain. Elements within the domain in this rank lie between the values returned by <a class="el" href="classyask_1_1yk__solution.html#ad7d9a4c12c5fb5111dfc1382e724f3cc" title="Get the first index of the sub-domain in this rank in the specified dimension. ">get_first_rank_domain_index()</a> and <a class="el" href="classyask_1_1yk__solution.html#af2d5546559dc281e9c588478cb65b1c8" title="Get the last index of the sub-domain in this rank the specified dimension. ">get_last_rank_domain_index()</a>, inclusive. If there is only one MPI rank, this is typically zero (0). If there is more than one MPI rank, the value depends on the the rank's position within the overall problem domain.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a> because <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a> assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>First domain index in this rank. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2d5546559dc281e9c588478cb65b1c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_last_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of the sub-domain in this rank the specified dimension. </p>
<p>This returns the last <em>overall</em> index within the domain in this rank (<em>not</em> one past the end). If there is only one MPI rank, this is typically one less than the value provided by <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the size of the solution domain for this rank. ">set_rank_domain_size()</a>. If there is more than one MPI rank, the value depends on the the rank's position within the overall problem domain. See <a class="el" href="classyask_1_1yk__solution.html#ad7d9a4c12c5fb5111dfc1382e724f3cc" title="Get the first index of the sub-domain in this rank in the specified dimension. ">get_first_rank_domain_index()</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a> because <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a> assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Last index in this rank. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10cfc055104248132c4a59e1e08d5fe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_overall_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the overall problem size in the specified dimension. </p>
<p>The overall domain indices in the specified dimension will range from zero (0) to <a class="el" href="classyask_1_1yk__solution.html#a10cfc055104248132c4a59e1e08d5fe9" title="Get the overall problem size in the specified dimension. ">get_overall_domain_size()</a> - 1, inclusive. Call <a class="el" href="classyask_1_1yk__solution.html#ad7d9a4c12c5fb5111dfc1382e724f3cc" title="Get the first index of the sub-domain in this rank in the specified dimension. ">get_first_rank_domain_index()</a> and <a class="el" href="classyask_1_1yk__solution.html#af2d5546559dc281e9c588478cb65b1c8" title="Get the last index of the sub-domain in this rank the specified dimension. ">get_last_rank_domain_index()</a> to find the subset of this domain in each rank.</p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a> because <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a> obtains the sub-domain sizes from other ranks. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of all ranks' domain sizes in the given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14cc5625fc524fe8eb8d3cedc66778aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::run_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>first_step_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>last_step_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the stencil solution for the specified steps. </p>
<p>The stencil(s) in the solution are applied to the grid data, setting the index variables as follows:</p><ol type="1">
<li>If temporal wave-front tiling is <em>not</em> used (the default):<ul>
<li>The step index (e.g., <code>t</code> for "time") will be sequentially set to values from <code>first_step_index</code> to <code>last_step_index</code>, inclusive.<ul>
<li>If the stencil equations were defined with dependencies on lower-valued steps, e.g., <code>t+1</code> depends on <code>t</code>, then <code>last_step_index</code> should be greater than or equal to <code>first_step_index</code> (forward solution).</li>
<li>If the stencil equations were defined with dependencies on higher-valued steps, e.g., <code>t-1</code> depends on <code>t</code>, then <code>last_step_index</code> should be less than or equal to <code>first_step_index</code> (reverse solution).</li>
</ul>
</li>
<li>For each step index, the domain indices will be set to values across the entire domain as returned by <a class="el" href="classyask_1_1yk__solution.html#a10cfc055104248132c4a59e1e08d5fe9" title="Get the overall problem size in the specified dimension. ">yk_solution::get_overall_domain_size()</a> (not necessarily sequentially).</li>
<li>MPI halo exchanges will occur as necessary before or during each step.</li>
<li>Since this function initiates MPI communication, it must be called on all MPI ranks, and it will block until all ranks have completed.</li>
</ul>
</li>
<li><b>[Advanced]</b> If temporal wave-front tiling <em>is</em> enabled via <a class="el" href="classyask_1_1yk__solution.html#a923afb4530ef5f0370f8bf55856fa040" title="[Advanced] Set the region size in the given dimension. ">set_region_size()</a>:<ul>
<li>The step index (e.g., <code>t</code> for "time") will be sequentially set to values from <code>first_step_index</code> to <code>last_step_index</code>, inclusive, within each region.<ul>
<li>The number of steps in a region may also be restricted by the size of the region in the step dimension. In that case, tiles will be done in slices of that size.</li>
</ul>
</li>
<li>For each step index within each region, the domain indices will be set to values across the entire region (not necessarily sequentially).</li>
<li>Ultimately, the stencil(s) will be applied to same the elements in both the step and domain dimensions as when wave-front tiling is not used.</li>
<li>MPI halo exchanges will occur before each number of steps in a region.</li>
</ul>
</li>
</ol>
<p>This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_step_index</td><td>First index in the step dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_step_index</td><td>Last index in the step dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46dc15b38732b30c820ffd7765292342"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::run_solution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>step_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Run the stencil solution for the specified step. </p>
<p>This function is simply an alias for <code>run_solution(step_index, step_index)</code>, i.e., the solution will be applied for exactly one step across the domain.</p>
<p>Typical C++ usage:</p>
<div class="fragment"><div class="line">soln-&gt;prepare_solution();</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> t = 1; t &lt;= num_steps; t++)</div><div class="line">    soln-&gt;run_solution(t);</div><div class="line">soln-&gt;end_solution();</div></div><!-- fragment --><p>As written, the above loop is identical to</p>
<div class="fragment"><div class="line">soln-&gt;prepare_solution();</div><div class="line">soln-&gt;run_solution(1, num_steps);</div><div class="line">soln-&gt;end_solution();</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The parameter is <em>not</em> the number of steps to run. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since only one step is taken per call, using this function effectively disables wave-front tiling. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step_index</td><td>Index in the step dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afac6a33fe5d098d31a844f4eba654b19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::end_solution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finish using a solution. </p>
<p>Performs a final MPI halo exchange. Releases shared ownership of memory used by the grids. This will result in deallocating each memory block that is not referenced by another shared pointer. </p>

</div>
</div>
<a class="anchor" id="ab2755703f0d90aa4e3ef36093a1976f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#ga12d1d46aeb01bd7509a8dc3251657f75">yk_stats_ptr</a> yask::yk_solution::get_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get performance statistics associated with preceding calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">run_solution()</a>. </p>
<p>Side effect: resets all statistics, so a subsequent call will measure performance after the current call. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to statistics object. </dd></dl>

</div>
</div>
<a class="anchor" id="a150bb5f7d351afd9b64744f32fea4f5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_solution::is_auto_tuner_enabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the auto-tuner is enabled on this rank. </p>
<p>The auto-tuner is enabled by default. It will become disabled after it has converged or after reset_auto_tuner(false) has been called. </p><dl class="section return"><dt>Returns</dt><dd>Whether the auto-tuner is still searching. </dd></dl>

</div>
</div>
<a class="anchor" id="a923afb4530ef5f0370f8bf55856fa040"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_region_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the region size in the given dimension. </p>
<p>This sets the approximate number of elements that are evaluated in each "region". This is a performance setting and should not affect the functional correctness or total number of elements evaluated. A region is typically the unit of work done by each top-level OpenMP parallel region. The actual number of elements evaluated in a region may be greater than the specified size due to rounding. The number of elements in a region may also be smaller than the specified size when the region is at the edge of the domain.</p>
<p>A region is most often used to specify the size of a temporal wave-front tile. Thus, you will normally specify the size of the region in the step dimension as well as all the domain dimensions. For example, <code>set_region_size("t", 4)</code> specifies that four time-steps will be executed in each region. The sizes of regions in the domain dimensions are typically set to fit within a large cache structure such as MCDRAM cache in an Intel(R) Xeon Phi(TM) processor.</p>
<p>In order to get the benefit of regions with multiple steps, you must also call <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">run_solution()</a> where the number of steps between its <code>first_step_index</code> and <code>last_step_index</code> arguments is greater than or equal to the step-size of the regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#ad8447a472034f4c9db2238dc18a50109" title="Get the solution step dimension. ">get_step_dim_name()</a> or <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in a region in this <code>dim</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acabb070ab8e0afbceb1db9a9a020c54e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_region_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the region size. </p>
<p>Returned value may be slightly larger than the value provided via <a class="el" href="classyask_1_1yk__solution.html#a923afb4530ef5f0370f8bf55856fa040" title="[Advanced] Set the region size in the given dimension. ">set_region_size()</a> due to rounding. </p><dl class="section return"><dt>Returns</dt><dd>Current settings of region size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#ad8447a472034f4c9db2238dc18a50109" title="Get the solution step dimension. ">get_step_dim_name()</a> or <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3bd7e95ea13631954d92a638badfb2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::set_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum amount of grid padding for all grids. </p>
<p>This sets the minimum number of elements in each grid that is reserved outside of the rank domain in the given dimension. This padding area can be used for required halo areas. At least the specified number of elements will be added to both sides, i.e., both "before" and "after" the domain.</p>
<p>The <em>actual</em> padding size will be the largest of the following values, additionally rounded up based on the vector-folding dimensions, cache-line alignment, and/or extensions needed for wave-front tiles:</p><ul>
<li>Halo size.</li>
<li>Value provided by any of the pad-size setting functions.</li>
</ul>
<p>The padding size cannot be changed after data storage has been allocated for a given grid; attempted changes to the pad size for such grids will be ignored. In addition, once a grid's padding is set, it cannot be reduced, only increased.</p>
<p>Use <a class="el" href="classyask_1_1yk__grid.html#a9ba5bc68fb89ff0f58e1adde054707ef" title="[Advanced] Set the minimum left padding in the specified dimension. ">yk_grid::set_left_min_pad_size</a> and <a class="el" href="classyask_1_1yk__grid.html#a33e38a33f098cc29c50abfe8dcfe0c38" title="[Advanced] Set the minimum right padding in the specified dimension. ">yk_grid::set_right_min_pad_size()</a> for specific setting of each grid. Call <a class="el" href="classyask_1_1yk__grid.html#aacd190b453a8c28d556bcf756da0c650" title="Get the left padding in the specified dimension. ">yk_grid::get_left_pad_size()</a> and <a class="el" href="classyask_1_1yk__grid.html#ae67d6e1269d8c334edd715971f9a76dc" title="Get the right padding in the specified dimension. ">yk_grid::get_right_pad_size()</a> to determine the actual padding sizes for a given grid. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a> for more information on grid sizes. Padding is only allowed in the domain dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Elements in this <code>dim</code> applied to both sides of the domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad245bacafc9fe7c91a29fe677b43526b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_solution::get_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the minimum amount of grid padding for all grids. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of minimum amount of grid padding for all grids. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a932fad2ede1aecef168189c0aa972b0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::reset_auto_tuner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Restart or disable the auto-tuner on this rank. </p>
<p>Under normal operation, an auto-tuner is invoked automatically during calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">run_solution()</a>. Currently, only the block size is set by the auto-tuner, and the search begins from the sizes set via <a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839" title="Set the block size in the given dimension. ">set_block_size()</a> or the default size if <a class="el" href="classyask_1_1yk__solution.html#abd3c7317bf1b397f332962d658f38839" title="Set the block size in the given dimension. ">set_block_size()</a> has not been called. This function is used to apply the current best-known settings if the tuner has been running, reset the state of the auto-tuner, and either restart its search or disable it from running. This call must be made on each rank where the change is desired. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>If <em>true</em>, start or restart the auto-tuner search. If <em>false</em>, disable the auto-tuner from running. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If <em>true</em>, print progress information to the debug object set via <a class="el" href="classyask_1_1yk__solution.html#aa315469b5836e531425836f4fc5eff1c" title="Set object to receive debug output. ">set_debug_output()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e92afeb1d201ea0174fa04029ec0077"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::run_auto_tuner_now </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Automatically tune selected settings immediately. </p>
<p>Executes a search algorithm to find [locally] optimum values for some of the settings. Under normal operation, an auto-tuner is invoked during calls to <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">run_solution()</a>. See <a class="el" href="classyask_1_1yk__solution.html#a932fad2ede1aecef168189c0aa972b0b" title="[Advanced] Restart or disable the auto-tuner on this rank. ">reset_auto_tuner()</a> for more information. This function causes the stencil solution to be run immediately until the auto-tuner converges on all ranks. It is useful for benchmarking, where performance is to be timed for a given number of steps after the best settings are found. This function should be called only <em>after</em> calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">prepare_solution()</a>. This call must be made on each rank. </p><dl class="section warning"><dt>Warning</dt><dd>Modifies the contents of the grids by calling <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">run_solution()</a> an arbitrary number of times, but without halo exchange. (See <a class="el" href="classyask_1_1yk__solution.html#a14cc5625fc524fe8eb8d3cedc66778aa" title="Run the stencil solution for the specified steps. ">run_solution()</a> for other restrictions and warnings.) Thus, grid data should be set <em>after</em> calling this function when used in a production or test setting where correct results are expected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>If <em>true</em>, print progress information to the debug object set via <a class="el" href="classyask_1_1yk__solution.html#aa315469b5836e531425836f4fc5eff1c" title="Set object to receive debug output. ">set_debug_output()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac40302135611353f57b626d4ff55af25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> yask::yk_solution::new_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new grid to the solution. </p>
<p>This is typically not needed because grids used by the stencils are pre-defined by the solution itself via the stencil compiler. However, a grid may be created explicitly via this function in order to use it for purposes other than by the pre-defined stencils within the current solution.</p>
<p>Grids created by this function will behave [mostly] like a pre-defined grid. For example,</p><ul>
<li>Step and domain dimensions must the same as those defined by <a class="el" href="classyask_1_1yc__node__factory.html#a5c92535a08258803f35bdacb31fc4682" title="Create a step-index node. ">yc_node_factory::new_step_index()</a> and <a class="el" href="classyask_1_1yc__node__factory.html#a7c47726eb7de2b9cd174cfcff7745699" title="Create a domain-index node. ">yc_node_factory::new_domain_index()</a>, respectively.</li>
<li>For each domain dimension of the grid, the new grid's domain size will be the same as that returned by <a class="el" href="classyask_1_1yk__solution.html#a1973cf0d0c10c12f01534fb41535586e" title="Get the domain size for this rank. ">get_rank_domain_size()</a>.</li>
<li>Calls to <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the size of the solution domain for this rank. ">set_rank_domain_size()</a> will resize the corresponding domain size in this grid.</li>
<li>This grid's first domain index in this rank will be determined by the position of this rank.</li>
<li>This grid's initial padding size will be the same as that returned by <a class="el" href="classyask_1_1yk__solution.html#ad245bacafc9fe7c91a29fe677b43526b" title="[Advanced] Get the minimum amount of grid padding for all grids. ">get_min_pad_size()</a>.</li>
<li>After creating a new grid, you can increase its padding sizes in the domain dimensions via <a class="el" href="classyask_1_1yk__grid.html#ac5dcbd72d78bcd819a44237feb95c5ca" title="[Advanced] Set the minimum padding in the specified dimension. ">yk_grid::set_min_pad_size()</a>, <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of grid padding for all grids. ">yk_solution::set_min_pad_size()</a>, etc.</li>
<li>For step and misc dimensions, you can change the desired size <a class="el" href="classyask_1_1yk__grid.html#a9f9c2e794661bbffc72b9648646b5456" title="[Advanced] Set the number of elements to allocate in the specified dimension. ">yk_grid::set_alloc_size()</a>.</li>
<li>Storage may be allocated via <a class="el" href="classyask_1_1yk__grid.html#a054d222630dc987cd5b960fcbfc46274" title="[Advanced] Explicitly allocate data-storage memory for this grid. ">yk_grid::alloc_storage()</a> or <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a>.</li>
</ul>
<p>Some behaviors are different from pre-defined grids. For example,</p><ul>
<li>You can create new "misc" dimensions during grid creation simply by naming them in the <code>dims</code> argument. Any dimension name that is not a step or domain dimension will become a misc dimension, whether or not it was defined via <a class="el" href="classyask_1_1yc__node__factory.html#a8d1db4e2ced1916ea0e362dd8030fae8" title="Create a new miscellaneous index. ">yc_node_factory::new_misc_index()</a>.</li>
<li>Grids created via <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">new_grid()</a> cannot be direct inputs or outputs of stencil equations. However, data in a grid created via <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">new_grid()</a> can be shared with a pre-defined grid via <a class="el" href="classyask_1_1yk__grid.html#af7d971de562e05adae61c4495650cd93" title="[Advanced] Use existing data-storage from specified grid. ">yk_grid::share_storage()</a> if and only if the sizes of all dimensions are compatible.</li>
</ul>
<p>If you want a grid that is not automatically resized based on the solution settings, use <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">new_fixed_size_grid()</a> instead.</p>
<dl class="section note"><dt>Note</dt><dd>A new grid contains only the meta-data for the grid; data storage is not yet allocated. Storage may be allocated in any of the methods listed in the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new grid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the grid; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accdf2fd4c36bc96a5f89ab536c35f586"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> yask::yk_solution::new_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new grid to the solution. </p>
<p>See documentation for the version of <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">new_grid()</a> with a vector of dimension names as a parameter. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new grid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the grid; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbe399771481546ab7f323c2f3f3984c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> yask::yk_solution::new_fixed_size_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new grid to the solution with a specified size. </p>
<p>This is typically not needed because grids used by the stencils are pre-defined by the solution itself via the stencil compiler. However, a grid may be created explicitly via this function in order to use it for purposes other than by the pre-defined stencils within the current solution.</p>
<p>The following behaviors are different from both pre-defined grids and those created via <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">new_grid()</a>:</p><ul>
<li>For each domain dimension of the grid, the new grid's domain size is provided during creation and cannot be changed.</li>
<li>Calls to <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the size of the solution domain for this rank. ">set_rank_domain_size()</a> will <em>not</em> resize the corresponding domain size in this grid.</li>
<li>This grid's first domain index in this rank will be fixed at zero (0) regardless of this rank's position.</li>
<li>This grid's padding size will be affected only by calls to <a class="el" href="classyask_1_1yk__grid.html#ac5dcbd72d78bcd819a44237feb95c5ca" title="[Advanced] Set the minimum padding in the specified dimension. ">yk_grid::set_min_pad_size()</a>, etc., i.e., <em>not</em> via <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of grid padding for all grids. ">yk_solution::set_min_pad_size()</a>.</li>
</ul>
<p>The following behaviors are the same as those of a pre-defined grid and those created via <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">new_grid()</a>:</p><ul>
<li>For step and misc dimensions, you can change the desired size <a class="el" href="classyask_1_1yk__grid.html#a9f9c2e794661bbffc72b9648646b5456" title="[Advanced] Set the number of elements to allocate in the specified dimension. ">yk_grid::set_alloc_size()</a>.</li>
<li>Storage may be allocated via <a class="el" href="classyask_1_1yk__grid.html#a054d222630dc987cd5b960fcbfc46274" title="[Advanced] Explicitly allocate data-storage memory for this grid. ">yk_grid::alloc_storage()</a> or <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a>.</li>
</ul>
<p>The following behaviors are different than a pre-defined grid but the same as those created via <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">new_grid()</a>:</p><ul>
<li>You can create new "misc" dimensions during grid creation simply by naming them in the <code>dims</code> argument. Any dimension name that is not a step or domain dimension will become a misc dimension, whether or not it was defined via <a class="el" href="classyask_1_1yc__node__factory.html#a8d1db4e2ced1916ea0e362dd8030fae8" title="Create a new miscellaneous index. ">yc_node_factory::new_misc_index()</a>.</li>
<li>Grids created via <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">new_fixed_size_grid()</a> cannot be direct inputs or outputs of stencil equations. However, data in a grid created via <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">new_fixed_size_grid()</a> can be shared with a pre-defined grid via <a class="el" href="classyask_1_1yk__grid.html#af7d971de562e05adae61c4495650cd93" title="[Advanced] Use existing data-storage from specified grid. ">yk_grid::share_storage()</a> if and only if the sizes of all dimensions are compatible.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A new grid contains only the meta-data for the grid; data storage is not yet allocated. Storage may be allocated in any of the methods listed in the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a>. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new grid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the grid; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_sizes</td><td>Initial allocation in each dimension. Must be exatly one size for each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f9313f45c164a5feb17502ed70e5b6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> yask::yk_solution::new_fixed_size_grid </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dim_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Add a new grid to the solution with a specified size. </p>
<p>See documentation for the version of <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">new_fixed_size_grid()</a> with a vector of dimension names as a parameter. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new grid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the grid; must be unique within the solution. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dims</td><td>List of names of all dimensions. Names must be valid C++ identifiers and not repeated within this grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_sizes</td><td>Initial allocation in each dimension. Must be exatly one size for each dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8bde8dfc73219cec84ad3033faabb90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_solution::set_default_numa_preferred </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numa_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data. </p>
<p>This value is used when allocating grids and MPI buffers. The NUMA "preferred node allocation" policy is used, meaning that memory will be allocated in an alternative node if the preferred one doesn't have enough space available or is otherwise restricted. Instead of specifying a NUMA node, a special value may be used to specify another policy as listed. This setting may be overridden for any specific grid. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if NUMA preference was set; <code>false</code> if NUMA preferences are not enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numa_node</td><td>Preferred NUMA node for data allocation. Alternatively, use <code>yask_numa_local</code> for explicit local-node allocation, <code>yask_numa_interleave</code> for interleaving pages across all nodes, or <code>yask_numa_none</code> for no explicit NUMA policy. These constants are defined in the <em>Variable Documentation</em> section of <a class="el" href="yk__solution__api_8hpp.html">yk_solution_api.hpp</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ea7c2dd016ce778f9eea0d3a3c87617"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_solution::get_default_numa_preferred </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of preferred NUMA node. </dd></dl>

</div>
</div>
<a class="anchor" id="ac111abbade055c4923cd0044360ec3b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_solution::apply_command_line_options </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set performance parameters from an option string. </p>
<p>Parses the string for options as if from a command-line. Example: "-bx 64 -block_threads 4" sets the block-size in the <em>x</em> dimension to 64 and the number of threads used to process each block to 4. See the help message from the YASK kernel binary for documentation on the command-line options.</p>
<dl class="section return"><dt>Returns</dt><dd>Any strings that were not recognized by the parser as options. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>String of arguments to parse. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd78008f0b70b509f8dfa94536f63a70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_solution::share_grid_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yk.html#ga2debaa7135bb46dfc295ca623bee2876">yk_solution_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Use data-storage from existing grids in specified solution. </p>
<p>Calls <a class="el" href="classyask_1_1yk__grid.html#af7d971de562e05adae61c4495650cd93" title="[Advanced] Use existing data-storage from specified grid. ">yk_grid::share_storage()</a> for each pair of grids that have the same name in this solution and the source solution. All conditions listed in <a class="el" href="classyask_1_1yk__grid.html#af7d971de562e05adae61c4495650cd93" title="[Advanced] Use existing data-storage from specified grid. ">yk_grid::share_storage()</a> must hold for each pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Solution from which grid storage will be shared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="yk__solution__api_8hpp_source.html">yk_solution_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
