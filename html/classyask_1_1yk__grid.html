<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>YASK: yask::yk_grid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">YASK
   </div>
   <div id="projectbrief">Yet Another Stencil Kernel: a software framework for creating HPC stencil code. Copyright 2014-2018 Intel Corporation.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>yask</b></li><li class="navelem"><a class="el" href="classyask_1_1yk__grid.html">yk_grid</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classyask_1_1yk__grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">yask::yk_grid Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__yk.html">YASK Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A run-time data container.  
 <a href="classyask_1_1yk__grid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="yk__grid__api_8hpp_source.html">yk_grid_api.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8736672d549fdd93f001f0697e9610e"><td class="memItemLeft" align="right" valign="top">virtual const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ab8736672d549fdd93f001f0697e9610e">get_name</a> () const  =0</td></tr>
<tr class="memdesc:ab8736672d549fdd93f001f0697e9610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the grid.  <a href="#ab8736672d549fdd93f001f0697e9610e">More...</a><br /></td></tr>
<tr class="separator:ab8736672d549fdd93f001f0697e9610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620127b679d00a51b43188ba493366ad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a620127b679d00a51b43188ba493366ad">is_fixed_size</a> () const  =0</td></tr>
<tr class="memdesc:a620127b679d00a51b43188ba493366ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether this grid is automatically resized based on the solution.  <a href="#a620127b679d00a51b43188ba493366ad">More...</a><br /></td></tr>
<tr class="separator:a620127b679d00a51b43188ba493366ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832359782f902f7770e7b99a68fe7fb1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a832359782f902f7770e7b99a68fe7fb1">get_num_dims</a> () const  =0</td></tr>
<tr class="memdesc:a832359782f902f7770e7b99a68fe7fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of dimensions used in this grid.  <a href="#a832359782f902f7770e7b99a68fe7fb1">More...</a><br /></td></tr>
<tr class="separator:a832359782f902f7770e7b99a68fe7fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3192f8e120de61ad510ecc82ea2a0eb4"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4">get_dim_names</a> () const  =0</td></tr>
<tr class="memdesc:a3192f8e120de61ad510ecc82ea2a0eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the dimensions in this grid.  <a href="#a3192f8e120de61ad510ecc82ea2a0eb4">More...</a><br /></td></tr>
<tr class="separator:a3192f8e120de61ad510ecc82ea2a0eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed4acdba5c91a92309132b19cb00c2a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#aeed4acdba5c91a92309132b19cb00c2a">is_dim_used</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:aeed4acdba5c91a92309132b19cb00c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether specified dimension exists in this grid.  <a href="#aeed4acdba5c91a92309132b19cb00c2a">More...</a><br /></td></tr>
<tr class="separator:aeed4acdba5c91a92309132b19cb00c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065b364e8a80332ed1a57f801fb0fdcb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a065b364e8a80332ed1a57f801fb0fdcb">get_rank_domain_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a065b364e8a80332ed1a57f801fb0fdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the domain size for this rank.  <a href="#a065b364e8a80332ed1a57f801fb0fdcb">More...</a><br /></td></tr>
<tr class="separator:a065b364e8a80332ed1a57f801fb0fdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a0a8da182bea5221feea38928f5c34"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a99a0a8da182bea5221feea38928f5c34">get_first_rank_domain_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a99a0a8da182bea5221feea38928f5c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of the sub-domain in this rank in the specified dimension.  <a href="#a99a0a8da182bea5221feea38928f5c34">More...</a><br /></td></tr>
<tr class="separator:a99a0a8da182bea5221feea38928f5c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643f877a21b1e0530472408c593992a7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a643f877a21b1e0530472408c593992a7">get_last_rank_domain_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a643f877a21b1e0530472408c593992a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of the sub-domain in this rank in the specified dimension.  <a href="#a643f877a21b1e0530472408c593992a7">More...</a><br /></td></tr>
<tr class="separator:a643f877a21b1e0530472408c593992a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f8cf2189b3a3f37bff87670b38b8ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ae4f8cf2189b3a3f37bff87670b38b8ea">get_left_halo_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:ae4f8cf2189b3a3f37bff87670b38b8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the left halo size in the specified dimension.  <a href="#ae4f8cf2189b3a3f37bff87670b38b8ea">More...</a><br /></td></tr>
<tr class="separator:ae4f8cf2189b3a3f37bff87670b38b8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f22f8f23c2874b833421ccd53de3b0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a23f22f8f23c2874b833421ccd53de3b0">get_right_halo_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a23f22f8f23c2874b833421ccd53de3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right halo size in the specified dimension.  <a href="#a23f22f8f23c2874b833421ccd53de3b0">More...</a><br /></td></tr>
<tr class="separator:a23f22f8f23c2874b833421ccd53de3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c7b868ec305ec7f133a8da6506fec4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a51c7b868ec305ec7f133a8da6506fec4">get_first_rank_halo_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a51c7b868ec305ec7f133a8da6506fec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of the left halo in this rank in the specified dimension.  <a href="#a51c7b868ec305ec7f133a8da6506fec4">More...</a><br /></td></tr>
<tr class="separator:a51c7b868ec305ec7f133a8da6506fec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5ab1c2be904ffe68bc3f248cae39d1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#afd5ab1c2be904ffe68bc3f248cae39d1">get_last_rank_halo_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:afd5ab1c2be904ffe68bc3f248cae39d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of the right halo in this rank in the specified dimension.  <a href="#afd5ab1c2be904ffe68bc3f248cae39d1">More...</a><br /></td></tr>
<tr class="separator:afd5ab1c2be904ffe68bc3f248cae39d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd190b453a8c28d556bcf756da0c650"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#aacd190b453a8c28d556bcf756da0c650">get_left_pad_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:aacd190b453a8c28d556bcf756da0c650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the left padding in the specified dimension.  <a href="#aacd190b453a8c28d556bcf756da0c650">More...</a><br /></td></tr>
<tr class="separator:aacd190b453a8c28d556bcf756da0c650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d6e1269d8c334edd715971f9a76dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ae67d6e1269d8c334edd715971f9a76dc">get_right_pad_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:ae67d6e1269d8c334edd715971f9a76dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the right padding in the specified dimension.  <a href="#ae67d6e1269d8c334edd715971f9a76dc">More...</a><br /></td></tr>
<tr class="separator:ae67d6e1269d8c334edd715971f9a76dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b472274438c75a042bd262ba381582"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a12b472274438c75a042bd262ba381582">get_left_extra_pad_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a12b472274438c75a042bd262ba381582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the extra left padding in the specified dimension.  <a href="#a12b472274438c75a042bd262ba381582">More...</a><br /></td></tr>
<tr class="separator:a12b472274438c75a042bd262ba381582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f3863f22b876b4d09957224d737ad1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a73f3863f22b876b4d09957224d737ad1">get_right_extra_pad_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a73f3863f22b876b4d09957224d737ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the extra right padding in the specified dimension.  <a href="#a73f3863f22b876b4d09957224d737ad1">More...</a><br /></td></tr>
<tr class="separator:a73f3863f22b876b4d09957224d737ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad7e15b5ddb5d47798b4c52b450adb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#aacad7e15b5ddb5d47798b4c52b450adb">get_alloc_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:aacad7e15b5ddb5d47798b4c52b450adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the storage allocation in the specified dimension.  <a href="#aacad7e15b5ddb5d47798b4c52b450adb">More...</a><br /></td></tr>
<tr class="separator:aacad7e15b5ddb5d47798b4c52b450adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ec6f9aedf5e0a9a53405c94eac2524"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ae0ec6f9aedf5e0a9a53405c94eac2524">get_first_misc_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:ae0ec6f9aedf5e0a9a53405c94eac2524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of a specified miscellaneous dimension.  <a href="#ae0ec6f9aedf5e0a9a53405c94eac2524">More...</a><br /></td></tr>
<tr class="separator:ae0ec6f9aedf5e0a9a53405c94eac2524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db4fc011bfa3fd81d84efa02f64b071"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a2db4fc011bfa3fd81d84efa02f64b071">get_last_misc_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a2db4fc011bfa3fd81d84efa02f64b071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last index of a specified miscellaneous dimension.  <a href="#a2db4fc011bfa3fd81d84efa02f64b071">More...</a><br /></td></tr>
<tr class="separator:a2db4fc011bfa3fd81d84efa02f64b071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575ac2bbd6ba7b7e07a71d3266a93c8d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a575ac2bbd6ba7b7e07a71d3266a93c8d">is_element_allocated</a> (const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices) const  =0</td></tr>
<tr class="memdesc:a575ac2bbd6ba7b7e07a71d3266a93c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an element at the given indices is allocated in this rank.  <a href="#a575ac2bbd6ba7b7e07a71d3266a93c8d">More...</a><br /></td></tr>
<tr class="separator:a575ac2bbd6ba7b7e07a71d3266a93c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bf9ab4fbea6bfcc35264a4745cddc0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a24bf9ab4fbea6bfcc35264a4745cddc0">is_element_allocated</a> (const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices) const  =0</td></tr>
<tr class="memdesc:a24bf9ab4fbea6bfcc35264a4745cddc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an element at the given indices is allocated in this rank.  <a href="#a24bf9ab4fbea6bfcc35264a4745cddc0">More...</a><br /></td></tr>
<tr class="separator:a24bf9ab4fbea6bfcc35264a4745cddc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8883712389516498e62add0f77bd631"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ad8883712389516498e62add0f77bd631">get_element</a> (const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices) const  =0</td></tr>
<tr class="memdesc:ad8883712389516498e62add0f77bd631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of one element in this grid.  <a href="#ad8883712389516498e62add0f77bd631">More...</a><br /></td></tr>
<tr class="separator:ad8883712389516498e62add0f77bd631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83d981bc5677e2a0d393a9cfd1f86be"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ab83d981bc5677e2a0d393a9cfd1f86be">get_element</a> (const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices) const  =0</td></tr>
<tr class="memdesc:ab83d981bc5677e2a0d393a9cfd1f86be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of one element in this grid.  <a href="#ab83d981bc5677e2a0d393a9cfd1f86be">More...</a><br /></td></tr>
<tr class="separator:ab83d981bc5677e2a0d393a9cfd1f86be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f93ff6dc86a5161a9a5b642e8a82698"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a9f93ff6dc86a5161a9a5b642e8a82698">set_element</a> (double val, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices, bool strict_indices=false)=0</td></tr>
<tr class="memdesc:a9f93ff6dc86a5161a9a5b642e8a82698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of one element in this grid.  <a href="#a9f93ff6dc86a5161a9a5b642e8a82698">More...</a><br /></td></tr>
<tr class="separator:a9f93ff6dc86a5161a9a5b642e8a82698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3e668472ede36e47eebb6bb712e1fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#add3e668472ede36e47eebb6bb712e1fb">set_element</a> (double val, const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices, bool strict_indices=false)=0</td></tr>
<tr class="memdesc:add3e668472ede36e47eebb6bb712e1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of one element in this grid.  <a href="#add3e668472ede36e47eebb6bb712e1fb">More...</a><br /></td></tr>
<tr class="separator:add3e668472ede36e47eebb6bb712e1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef822f18cfeaee48ccb78df3c83daff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a9ef822f18cfeaee48ccb78df3c83daff">get_elements_in_slice</a> (void *buffer_ptr, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;first_indices, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;last_indices) const  =0</td></tr>
<tr class="memdesc:a9ef822f18cfeaee48ccb78df3c83daff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write elements within specified subset of this grid into a buffer.  <a href="#a9ef822f18cfeaee48ccb78df3c83daff">More...</a><br /></td></tr>
<tr class="separator:a9ef822f18cfeaee48ccb78df3c83daff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c882cadb38d38370c581ef2c6ed8dd6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a5c882cadb38d38370c581ef2c6ed8dd6">add_to_element</a> (double val, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices, bool strict_indices=false)=0</td></tr>
<tr class="memdesc:a5c882cadb38d38370c581ef2c6ed8dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add to the value of one grid element.  <a href="#a5c882cadb38d38370c581ef2c6ed8dd6">More...</a><br /></td></tr>
<tr class="separator:a5c882cadb38d38370c581ef2c6ed8dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b43afc6a6f0fab33fadbb5cd3196bd6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a5b43afc6a6f0fab33fadbb5cd3196bd6">add_to_element</a> (double val, const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices, bool strict_indices=false)=0</td></tr>
<tr class="memdesc:a5b43afc6a6f0fab33fadbb5cd3196bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically add to the value of one grid element.  <a href="#a5b43afc6a6f0fab33fadbb5cd3196bd6">More...</a><br /></td></tr>
<tr class="separator:a5b43afc6a6f0fab33fadbb5cd3196bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f45864a94cad82e0b54df6a2cc95301"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a9f45864a94cad82e0b54df6a2cc95301">set_all_elements_same</a> (double val)=0</td></tr>
<tr class="memdesc:a9f45864a94cad82e0b54df6a2cc95301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all grid elements to the same value.  <a href="#a9f45864a94cad82e0b54df6a2cc95301">More...</a><br /></td></tr>
<tr class="separator:a9f45864a94cad82e0b54df6a2cc95301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5378027cf69c0456b56458ef215e3404"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a5378027cf69c0456b56458ef215e3404">set_elements_in_slice_same</a> (double val, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;first_indices, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;last_indices, bool strict_indices=false)=0</td></tr>
<tr class="memdesc:a5378027cf69c0456b56458ef215e3404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize grid elements within specified subset of the grid to the same value.  <a href="#a5378027cf69c0456b56458ef215e3404">More...</a><br /></td></tr>
<tr class="separator:a5378027cf69c0456b56458ef215e3404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c07955bb53c6ee8775dc1b1f459015"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ae1c07955bb53c6ee8775dc1b1f459015">set_elements_in_slice</a> (const void *buffer_ptr, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;first_indices, const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;last_indices)=0</td></tr>
<tr class="memdesc:ae1c07955bb53c6ee8775dc1b1f459015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set grid elements within specified subset of the grid from values in a buffer.  <a href="#ae1c07955bb53c6ee8775dc1b1f459015">More...</a><br /></td></tr>
<tr class="separator:ae1c07955bb53c6ee8775dc1b1f459015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3615b3324d33e65f229254c3d567b15b"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a3615b3324d33e65f229254c3d567b15b">format_indices</a> (const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices) const  =0</td></tr>
<tr class="memdesc:a3615b3324d33e65f229254c3d567b15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the indices for pretty-printing.  <a href="#a3615b3324d33e65f229254c3d567b15b">More...</a><br /></td></tr>
<tr class="separator:a3615b3324d33e65f229254c3d567b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695ec7b3053af2b1af4e97991e0b1c1c"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a695ec7b3053af2b1af4e97991e0b1c1c">format_indices</a> (const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;indices) const  =0</td></tr>
<tr class="memdesc:a695ec7b3053af2b1af4e97991e0b1c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format the indices for pretty-printing.  <a href="#a695ec7b3053af2b1af4e97991e0b1c1c">More...</a><br /></td></tr>
<tr class="separator:a695ec7b3053af2b1af4e97991e0b1c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76951eeaa5081676dde0ab9e6f57433a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a76951eeaa5081676dde0ab9e6f57433a">set_numa_preferred</a> (int numa_node)=0</td></tr>
<tr class="memdesc:a76951eeaa5081676dde0ab9e6f57433a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data.  <a href="#a76951eeaa5081676dde0ab9e6f57433a">More...</a><br /></td></tr>
<tr class="separator:a76951eeaa5081676dde0ab9e6f57433a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1fbb741b6bb45aed06fb3fac65fb4a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a4c1fbb741b6bb45aed06fb3fac65fb4a">get_numa_preferred</a> () const  =0</td></tr>
<tr class="memdesc:a4c1fbb741b6bb45aed06fb3fac65fb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data.  <a href="#a4c1fbb741b6bb45aed06fb3fac65fb4a">More...</a><br /></td></tr>
<tr class="separator:a4c1fbb741b6bb45aed06fb3fac65fb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba5bc68fb89ff0f58e1adde054707ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a9ba5bc68fb89ff0f58e1adde054707ef">set_left_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a9ba5bc68fb89ff0f58e1adde054707ef"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum left padding in the specified dimension.  <a href="#a9ba5bc68fb89ff0f58e1adde054707ef">More...</a><br /></td></tr>
<tr class="separator:a9ba5bc68fb89ff0f58e1adde054707ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e38a33f098cc29c50abfe8dcfe0c38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a33e38a33f098cc29c50abfe8dcfe0c38">set_right_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a33e38a33f098cc29c50abfe8dcfe0c38"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum right padding in the specified dimension.  <a href="#a33e38a33f098cc29c50abfe8dcfe0c38">More...</a><br /></td></tr>
<tr class="separator:a33e38a33f098cc29c50abfe8dcfe0c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dcbd72d78bcd819a44237feb95c5ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ac5dcbd72d78bcd819a44237feb95c5ca">set_min_pad_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:ac5dcbd72d78bcd819a44237feb95c5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the minimum padding in the specified dimension.  <a href="#ac5dcbd72d78bcd819a44237feb95c5ca">More...</a><br /></td></tr>
<tr class="separator:ac5dcbd72d78bcd819a44237feb95c5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac687166a85bee225d8aa14f44bbfa6f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#aac687166a85bee225d8aa14f44bbfa6f">set_left_halo_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:aac687166a85bee225d8aa14f44bbfa6f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the left halo size in the specified dimension.  <a href="#aac687166a85bee225d8aa14f44bbfa6f">More...</a><br /></td></tr>
<tr class="separator:aac687166a85bee225d8aa14f44bbfa6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ac53814983d98603279bcab57ad3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#aa47ac53814983d98603279bcab57ad3d">set_right_halo_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:aa47ac53814983d98603279bcab57ad3d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the right halo size in the specified dimension.  <a href="#aa47ac53814983d98603279bcab57ad3d">More...</a><br /></td></tr>
<tr class="separator:aa47ac53814983d98603279bcab57ad3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21feb2f51ded1b7a8f7fdb1591be263"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ae21feb2f51ded1b7a8f7fdb1591be263">set_halo_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:ae21feb2f51ded1b7a8f7fdb1591be263"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the left and right halo sizes in the specified dimension.  <a href="#ae21feb2f51ded1b7a8f7fdb1591be263">More...</a><br /></td></tr>
<tr class="separator:ae21feb2f51ded1b7a8f7fdb1591be263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9c2e794661bbffc72b9648646b5456"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a9f9c2e794661bbffc72b9648646b5456">set_alloc_size</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> size)=0</td></tr>
<tr class="memdesc:a9f9c2e794661bbffc72b9648646b5456"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the number of elements to allocate in the specified dimension.  <a href="#a9f9c2e794661bbffc72b9648646b5456">More...</a><br /></td></tr>
<tr class="separator:a9f9c2e794661bbffc72b9648646b5456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3485a6583f0b4c576b4db40d960aad9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#af3485a6583f0b4c576b4db40d960aad9">set_first_misc_index</a> (const std::string &amp;dim, <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> idx)=0</td></tr>
<tr class="memdesc:af3485a6583f0b4c576b4db40d960aad9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Set the first index of a specified miscellaneous dimension.  <a href="#af3485a6583f0b4c576b4db40d960aad9">More...</a><br /></td></tr>
<tr class="separator:af3485a6583f0b4c576b4db40d960aad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f747153ff9c3f67575754a0bfafedc1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1">get_first_rank_alloc_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a4f747153ff9c3f67575754a0bfafedc1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the first accessible index in this grid in this rank in the specified dimension.  <a href="#a4f747153ff9c3f67575754a0bfafedc1">More...</a><br /></td></tr>
<tr class="separator:a4f747153ff9c3f67575754a0bfafedc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb59507b9509f99d33a5cf72d997be7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7">get_last_rank_alloc_index</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:acfb59507b9509f99d33a5cf72d997be7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get the last accessible index in this grid in this rank in the specified dimension.  <a href="#acfb59507b9509f99d33a5cf72d997be7">More...</a><br /></td></tr>
<tr class="separator:acfb59507b9509f99d33a5cf72d997be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285627d34759f233aa3e054333e7c60e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a285627d34759f233aa3e054333e7c60e">is_storage_allocated</a> () const  =0</td></tr>
<tr class="memdesc:a285627d34759f233aa3e054333e7c60e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine whether storage has been allocated.  <a href="#a285627d34759f233aa3e054333e7c60e">More...</a><br /></td></tr>
<tr class="separator:a285627d34759f233aa3e054333e7c60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51a768ecd909e73ed232360079c1525"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#ab51a768ecd909e73ed232360079c1525">get_num_storage_bytes</a> () const  =0</td></tr>
<tr class="memdesc:ab51a768ecd909e73ed232360079c1525"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine size of raw storage in bytes.  <a href="#ab51a768ecd909e73ed232360079c1525">More...</a><br /></td></tr>
<tr class="separator:ab51a768ecd909e73ed232360079c1525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8bb55d8708ecf1e9b332bf96470a4a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a1a8bb55d8708ecf1e9b332bf96470a4a">get_num_storage_elements</a> () const  =0</td></tr>
<tr class="memdesc:a1a8bb55d8708ecf1e9b332bf96470a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determine size of raw storage in elements.  <a href="#a1a8bb55d8708ecf1e9b332bf96470a4a">More...</a><br /></td></tr>
<tr class="separator:a1a8bb55d8708ecf1e9b332bf96470a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054d222630dc987cd5b960fcbfc46274"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a054d222630dc987cd5b960fcbfc46274">alloc_storage</a> ()=0</td></tr>
<tr class="memdesc:a054d222630dc987cd5b960fcbfc46274"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Explicitly allocate data-storage memory for this grid.  <a href="#a054d222630dc987cd5b960fcbfc46274">More...</a><br /></td></tr>
<tr class="separator:a054d222630dc987cd5b960fcbfc46274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516c37b0cc9890fa00012f835c030352"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a516c37b0cc9890fa00012f835c030352">release_storage</a> ()=0</td></tr>
<tr class="memdesc:a516c37b0cc9890fa00012f835c030352"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Explicitly release any allocated data-storage for this grid.  <a href="#a516c37b0cc9890fa00012f835c030352">More...</a><br /></td></tr>
<tr class="separator:a516c37b0cc9890fa00012f835c030352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0db2cbe2a067e301c843ea95dec5c79"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#af0db2cbe2a067e301c843ea95dec5c79">is_storage_layout_identical</a> (const <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> other) const  =0</td></tr>
<tr class="memdesc:af0db2cbe2a067e301c843ea95dec5c79"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Determines whether storage layout is the same as another grid.  <a href="#af0db2cbe2a067e301c843ea95dec5c79">More...</a><br /></td></tr>
<tr class="separator:af0db2cbe2a067e301c843ea95dec5c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d971de562e05adae61c4495650cd93"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#af7d971de562e05adae61c4495650cd93">share_storage</a> (<a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a> source)=0</td></tr>
<tr class="memdesc:af7d971de562e05adae61c4495650cd93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Use existing data-storage from specified grid.  <a href="#af7d971de562e05adae61c4495650cd93">More...</a><br /></td></tr>
<tr class="separator:af7d971de562e05adae61c4495650cd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff12df3c3582a022fdf6bfde6626806"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#aeff12df3c3582a022fdf6bfde6626806">get_raw_storage_buffer</a> ()=0</td></tr>
<tr class="memdesc:aeff12df3c3582a022fdf6bfde6626806"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Advanced]</b> Get pointer to raw data storage buffer.  <a href="#aeff12df3c3582a022fdf6bfde6626806">More...</a><br /></td></tr>
<tr class="separator:aeff12df3c3582a022fdf6bfde6626806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735b2d2efe08af9f15275a8139e22079"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a735b2d2efe08af9f15275a8139e22079">get_halo_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a735b2d2efe08af9f15275a8139e22079"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Get the left halo size in the specified dimension.  <a href="#a735b2d2efe08af9f15275a8139e22079">More...</a><br /></td></tr>
<tr class="separator:a735b2d2efe08af9f15275a8139e22079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5576bdf5a8dff49f467430c2103661"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#a3d5576bdf5a8dff49f467430c2103661">get_pad_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:a3d5576bdf5a8dff49f467430c2103661"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Get the left padding in the specified dimension.  <a href="#a3d5576bdf5a8dff49f467430c2103661">More...</a><br /></td></tr>
<tr class="separator:a3d5576bdf5a8dff49f467430c2103661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec439943d3e07f05703c2895989c18b9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classyask_1_1yk__grid.html#aec439943d3e07f05703c2895989c18b9">get_extra_pad_size</a> (const std::string &amp;dim) const  =0</td></tr>
<tr class="memdesc:aec439943d3e07f05703c2895989c18b9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>[Deprecated]</b> Get the extra left padding in the specified dimension.  <a href="#aec439943d3e07f05703c2895989c18b9">More...</a><br /></td></tr>
<tr class="separator:aec439943d3e07f05703c2895989c18b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A run-time data container. </p>
<p>"Grid" is a generic term for any n-dimensional array. A 0-dim grid is a scalar, a 1-dim grid is an array, etc. A run-time grid contains data, unlike <a class="el" href="classyask_1_1yc__grid.html" title="A compile-time data variable. ">yc_grid</a>, a compile-time grid variable.</p>
<p>Typically, access to each grid is obtained via <a class="el" href="classyask_1_1yk__solution.html#af882342252120bf3b7236d0be99ffbe0" title="Get the specified grid. ">yk_solution::get_grid()</a>. You may also use <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">yk_solution::new_grid()</a> or <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">yk_solution::new_fixed_size_grid()</a> if you need a grid that is not part of the pre-defined solution.</p>
<p>Each dimension of a grid is one of the following:</p><ul>
<li>The <em>step</em> dimension, typically time ("t"), as returned from <a class="el" href="classyask_1_1yk__solution.html#ad8447a472034f4c9db2238dc18a50109" title="Get the solution step dimension. ">yk_solution::get_step_dim_name()</a>.</li>
<li>A <em>domain</em> dimension, typically a spatial dimension such as "x" or "y", as returned from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>.</li>
<li>A <em>miscellaneous</em> dimension, which is any dimension that is not a step or domain dimension. These may be returned via <a class="el" href="classyask_1_1yk__solution.html#adef99aeda1db20563066c00a66533fbc" title="Get all the miscellaneous dimension names. ">yk_solution::get_misc_dim_names()</a> if they were defined in the YASK compiler, or they may be any other name that is not a step or domain dimension.</li>
</ul>
<p>In the step dimension, there is no fixed domain size, and no specified first or last index. However, there is an allocation size, which is the number of values in the step dimension that are stored in memory. Step-dimension indices "wrap-around" within this allocation to reuse memory. For example, if the step dimension is "t", and the t-dimension allocation size is 3, then t=-2, t=0, t=3, t=6, ..., t=303, etc. would all alias to the same addresses in memory.</p>
<p>In each domain dimension, grid sizes include the following components:</p><ul>
<li>The <em>domain</em> is the elements to which the stencils are applied.</li>
<li>The <em>left padding</em> is all the elements before the domain and includes the left halo.</li>
<li>The <em>right padding</em> is all the elements before the domain and includes the right halo.</li>
<li>The <em>left halo</em> is the elements just before the domain which must be copied between preceding ranks during halo exchanges. The left halo is contained within the left padding.</li>
<li>The <em>right halo</em> is the elements just after the domain which must be copied between following ranks during halo exchanges. The right halo is contained within the right padding.</li>
<li>The <em>extra left padding</em> is the elements before the domain and left halo and thus does not include the left halo.</li>
<li>The <em>extra right padding</em> is the elements after the domain and right halo and thus does not include the right halo.</li>
<li>The <em>allocation</em> includes the left padding, domain, and right padding.</li>
</ul>
<p>Domain sizes specified via <a class="el" href="classyask_1_1yk__solution.html#a155d8f4a38da9da11488a18cca50bae8" title="Set the size of the solution domain for this rank. ">yk_solution::set_rank_domain_size()</a> apply to each MPI rank. Visually, in each of the domain dimensions, these sizes are related as follows in each rank: </p><table class="doxtable">
<tr>
<td>extra left padding </td><td>left halo </td><td rowspan="2">domain </td><td>right halo </td><td>extra right padding </td></tr>
<tr>
<td colspan="2"><center>left padding</center> </td><td colspan="2"><center>right padding</center> </td></tr>
<tr>
<td colspan="5"><center>allocation</center> </td></tr>
</table>
<p>If MPI is not enabled, a rank's domain is equivalent to the entire problem size. If MPI is enabled, the domains of the ranks are logically abutted to create the overall problem domain in each dimension: </p><table class="doxtable">
<tr>
<td>extra left padding of rank A </td><td>halo of rank A </td><td>domain of rank A </td><td>domain of rank B </td><td>... </td><td>domain of rank Z </td><td>halo of rank Z </td><td>extra right padding of rank Z </td></tr>
<tr>
<td colspan="2"><center>left padding of rank A</center> </td><td colspan="4"><center>overall problem domain</center> </td><td colspan="2"><center>right padding of rank Z</center> </td></tr>
</table>
<p>The intermediate halos and paddings also exist, but are not shown in the above diagram. The halos overlap the domains of adjacent ranks. For example, the left halo of rank B in the diagram would overlap the domain of rank A. Data in these overlapped areas are exchanged as needed during stencil application to maintain a consistent values as if there was only one rank.</p>
<p>In each miscellaneous dimension, there is only an allocation size, and there is no wrap-around as in the step dimension. Each index must be between its first and last allowed value.</p>
<p>All sizes are expressed in numbers of elements. Each element may be a 4-byte (single precision) or 8-byte (double precision) floating-point value as returned by <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a>.</p>
<p>Initially, a grid is not assigned any allocated storage. This is done to allow modification of domain, padding, and other allocation sizes before allocation. Once the allocation sizes have been set in all dimensions, the data storage itself may be allocated. This can be done in any of the following ways:</p><ul>
<li>Storage for all grids without data storage will be automatically allocated when <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a> is called.</li>
<li>Storage for a specific grid may be allocated before calling <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a> via <a class="el" href="classyask_1_1yk__grid.html#a054d222630dc987cd5b960fcbfc46274" title="[Advanced] Explicitly allocate data-storage memory for this grid. ">yk_grid::alloc_storage()</a>.</li>
<li><b>[Advanced]</b> Storage for a specific grid may be shared with another grid with existing storage via <a class="el" href="classyask_1_1yk__grid.html#af7d971de562e05adae61c4495650cd93" title="[Advanced] Use existing data-storage from specified grid. ">yk_grid::share_storage()</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The domain index arguments to the <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a> functions that require indices are <em>always</em> relative to the overall problem; they are <em>not</em> relative to the current rank. The first and last overall-problem index that lies within a rank can be retrieved via <a class="el" href="classyask_1_1yk__solution.html#ad7d9a4c12c5fb5111dfc1382e724f3cc" title="Get the first index of the sub-domain in this rank in the specified dimension. ">yk_solution::get_first_rank_domain_index()</a> and <a class="el" href="classyask_1_1yk__solution.html#af2d5546559dc281e9c588478cb65b1c8" title="Get the last index of the sub-domain in this rank the specified dimension. ">yk_solution::get_last_rank_domain_index()</a>, respectively. The first and last accessible index that lies within a rank for a given grid can be retrieved via <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">yk_grid::get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">yk_grid::get_last_rank_alloc_index()</a>, respectively. Also, index arguments are always inclusive. Specifically, for functions that return or require a "last" index, that index indicates the last one in the relevant range, i.e., <em>not</em> one past the last value (this is more like Fortran and Perl than Python and Lisp). </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab8736672d549fdd93f001f0697e9610e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::string&amp; yask::yk_grid::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the grid. </p>
<dl class="section return"><dt>Returns</dt><dd>String containing name provided via <a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802" title="Create an n-dimensional grid variable in the solution. ">yc_solution::new_grid()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a620127b679d00a51b43188ba493366ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_grid::is_fixed_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether this grid is automatically resized based on the solution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this grid was created via <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">yk_solution::new_fixed_size_grid()</a> or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a832359782f902f7770e7b99a68fe7fb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_grid::get_num_dims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of dimensions used in this grid. </p>
<p>This may include domain, step, and/or miscellaneous dimensions. </p><dl class="section return"><dt>Returns</dt><dd>Number of dimensions created via <a class="el" href="classyask_1_1yc__solution.html#a6d009c433e6d6501821ae01d37897802" title="Create an n-dimensional grid variable in the solution. ">yc_solution::new_grid()</a>, <a class="el" href="classyask_1_1yk__solution.html#ac40302135611353f57b626d4ff55af25" title="[Advanced] Add a new grid to the solution. ">yk_solution::new_grid()</a>, or <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">yk_solution::new_fixed_size_grid()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3192f8e120de61ad510ecc82ea2a0eb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; yask::yk_grid::get_dim_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the dimensions in this grid. </p>
<p>This may include domain, step, and/or miscellaneous dimensions. </p><dl class="section return"><dt>Returns</dt><dd>List of names of all the dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="aeed4acdba5c91a92309132b19cb00c2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_grid::is_dim_used </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether specified dimension exists in this grid. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if dimension exists (including step-dimension), <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a065b364e8a80332ed1a57f801fb0fdcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_rank_domain_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the domain size for this rank. </p>
<dl class="section return"><dt>Returns</dt><dd>The same value as <a class="el" href="classyask_1_1yk__solution.html#a1973cf0d0c10c12f01534fb41535586e" title="Get the domain size for this rank. ">yk_solution::get_rank_domain_size()</a> if <a class="el" href="classyask_1_1yk__grid.html#a620127b679d00a51b43188ba493366ad" title="Determine whether this grid is automatically resized based on the solution. ">is_fixed_size()</a> returns <code>false</code> or the fixed sized provided via <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">yk_solution::new_fixed_size_grid()</a> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99a0a8da182bea5221feea38928f5c34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_first_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of the sub-domain in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as <a class="el" href="classyask_1_1yk__solution.html#ad7d9a4c12c5fb5111dfc1382e724f3cc" title="Get the first index of the sub-domain in this rank in the specified dimension. ">yk_solution::get_first_rank_domain_index()</a> if <a class="el" href="classyask_1_1yk__grid.html#a620127b679d00a51b43188ba493366ad" title="Determine whether this grid is automatically resized based on the solution. ">is_fixed_size()</a> returns <code>false</code> or zero (0) otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a643f877a21b1e0530472408c593992a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_last_rank_domain_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of the sub-domain in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The same value as <a class="el" href="classyask_1_1yk__solution.html#af2d5546559dc281e9c588478cb65b1c8" title="Get the last index of the sub-domain in this rank the specified dimension. ">yk_solution::get_last_rank_domain_index()</a> if <a class="el" href="classyask_1_1yk__grid.html#a620127b679d00a51b43188ba493366ad" title="Determine whether this grid is automatically resized based on the solution. ">is_fixed_size()</a> returns <code>false</code> or one less than the fixed sized provided via <a class="el" href="classyask_1_1yk__solution.html#adbe399771481546ab7f323c2f3f3984c" title="[Advanced] Add a new grid to the solution with a specified size. ">yk_solution::new_fixed_size_grid()</a> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae4f8cf2189b3a3f37bff87670b38b8ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_left_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the left halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler. </p><dl class="section return"><dt>Returns</dt><dd>Elements in halo in given dimension before the domain. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23f22f8f23c2874b833421ccd53de3b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_right_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the right halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler. </p><dl class="section return"><dt>Returns</dt><dd>Elements in halo in given dimension after the domain. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51c7b868ec305ec7f133a8da6506fec4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_first_rank_halo_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of the left halo in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The first index of left halo in this rank or the same value as <a class="el" href="classyask_1_1yk__grid.html#a99a0a8da182bea5221feea38928f5c34" title="Get the first index of the sub-domain in this rank in the specified dimension. ">yk_grid::get_first_rank_domain_index()</a> if the left halo has zero size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd5ab1c2be904ffe68bc3f248cae39d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_last_rank_halo_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of the right halo in this rank in the specified dimension. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be called only <em>after</em> calling prepare_solution() because prepare_solution() assigns this rank's position in the problem domain. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The last index of right halo in this rank or the same value as <a class="el" href="classyask_1_1yk__grid.html#a643f877a21b1e0530472408c593992a7" title="Get the last index of the sub-domain in this rank in the specified dimension. ">yk_grid::get_last_rank_domain_index()</a> if the right halo has zero size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacd190b453a8c28d556bcf756da0c650"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_left_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the left padding in the specified dimension. </p>
<p>The left padding is the memory allocated before the domain in a given dimension. The left padding size includes the left halo size. The value may be slightly larger than that provided via <a class="el" href="classyask_1_1yk__grid.html#a9ba5bc68fb89ff0f58e1adde054707ef" title="[Advanced] Set the minimum left padding in the specified dimension. ">set_left_min_pad_size()</a>, etc. due to rounding. </p><dl class="section return"><dt>Returns</dt><dd>Elements in left padding in given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae67d6e1269d8c334edd715971f9a76dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_right_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the right padding in the specified dimension. </p>
<p>The right padding is the memory allocated after the domain in a given dimension. The right padding size includes the right halo size. The value may be slightly larger than that provided via <a class="el" href="classyask_1_1yk__grid.html#a33e38a33f098cc29c50abfe8dcfe0c38" title="[Advanced] Set the minimum right padding in the specified dimension. ">set_right_min_pad_size()</a>, etc. due to rounding. </p><dl class="section return"><dt>Returns</dt><dd>Elements in right padding in given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12b472274438c75a042bd262ba381582"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_left_extra_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the extra left padding in the specified dimension. </p>
<p>The <em>extra</em> padding size is the left padding size minus the left halo size. </p><dl class="section return"><dt>Returns</dt><dd>Elements in padding in given dimension before the left halo area. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73f3863f22b876b4d09957224d737ad1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_right_extra_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the extra right padding in the specified dimension. </p>
<p>The <em>extra</em> padding size is the right padding size minus the right halo size. </p><dl class="section return"><dt>Returns</dt><dd>Elements in padding in given dimension after the right halo area. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aacad7e15b5ddb5d47798b4c52b450adb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_alloc_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the storage allocation in the specified dimension. </p>
<p>For the step dimension, this is the specified allocation and does not typically depend on the number of steps evaluated. For the non-step dimensions, this includes the domain and padding sizes. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a> for information on grid sizes. </p><dl class="section return"><dt>Returns</dt><dd>allocation in number of elements (not bytes). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0ec6f9aedf5e0a9a53405c94eac2524"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_first_misc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first index of a specified miscellaneous dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>the first allowed index in a non-step and non-domain dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#adef99aeda1db20563066c00a66533fbc" title="Get all the miscellaneous dimension names. ">yk_solution::get_misc_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2db4fc011bfa3fd81d84efa02f64b071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_last_misc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last index of a specified miscellaneous dimension. </p>
<dl class="section return"><dt>Returns</dt><dd>the last allowed index in a non-step and non-domain dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#adef99aeda1db20563066c00a66533fbc" title="Get all the miscellaneous dimension names. ">yk_solution::get_misc_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a575ac2bbd6ba7b7e07a71d3266a93c8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_grid::is_element_allocated </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an element at the given indices is allocated in this rank. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if index values fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension; <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24bf9ab4fbea6bfcc35264a4745cddc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_grid::is_element_allocated </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether an element at the given indices is allocated in this rank. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if index values fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension; <code>false</code> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8883712389516498e62add0f77bd631"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double yask::yk_grid::get_element </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the value of one element in this grid. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension. </p><dl class="section return"><dt>Returns</dt><dd>value in grid at given multi-dimensional location. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab83d981bc5677e2a0d393a9cfd1f86be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double yask::yk_grid::get_element </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the value of one element in this grid. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension. </p><dl class="section note"><dt>Note</dt><dd>The return value is a double-precision floating-point value, but it will be converted from a single-precision if <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a> returns 4. </dd>
<dd>
This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>value in grid at given multi-dimensional location. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f93ff6dc86a5161a9a5b642e8a82698"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::set_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of one element in this grid. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension. </p><dl class="section note"><dt>Note</dt><dd>The parameter value is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a> returns 4. If storage has not been allocated for this grid, this will have no effect. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Element in grid will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add3e668472ede36e47eebb6bb712e1fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::set_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of one element in this grid. </p>
<p>Provide the number of indices equal to the number of dimensions in the grid. Indices beyond that will be ignored. Indices are relative to the <em>overall</em> problem domain. If any index values fall outside of the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension, this will have no effect. </p><dl class="section note"><dt>Note</dt><dd>The parameter value is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a> returns 4. If storage has not been allocated for this grid, this will have no effect. </dd>
<dd>
This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Element in grid will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ef822f18cfeaee48ccb78df3c83daff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_elements_in_slice </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write elements within specified subset of this grid into a buffer. </p>
<p>Reads all elements from <code>first_indices</code> to <code>last_indices</code> in each dimension and writes them to consecutive memory locations in the buffer. Indices in the buffer progress in row-major order. The buffer pointed to must contain the number of bytes equal to <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a> multiplied by the number of elements in the specified slice. Since the reads proceed in row-major order, the last index is "unit-stride" in the buffer. Provide indices in two lists in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements read. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_ptr</td><td>Pointer to buffer where values will be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_indices</td><td>List of initial indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_indices</td><td>List of final indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c882cadb38d38370c581ef2c6ed8dd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::add_to_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically add to the value of one grid element. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension if <code>strict_indices</code> is set to true. Updates are OpenMP atomic, meaning that this function can be called by several OpenMP threads without causing a race condition. </p><dl class="section note"><dt>Note</dt><dd>The parameter value is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a> returns 4. If storage has not been allocated for this grid, this will have no effect. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements updated. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>This value will be added to element in grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b43afc6a6f0fab33fadbb5cd3196bd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::add_to_element </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically add to the value of one grid element. </p>
<p>Provide the number of indices equal to the number of dimensions in the grid. Indices beyond that will be ignored. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension if <code>strict_indices</code> is set to true. Updates are OpenMP atomic, meaning that this function can be called by several OpenMP threads without causing a race condition. </p><dl class="section note"><dt>Note</dt><dd>The parameter value is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a> returns 4. If storage has not been allocated for this grid, this will have no effect. </dd>
<dd>
This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Number of elements set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>This value will be added to element in grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, indices outside of domain and padding result in no change to grid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f45864a94cad82e0b54df6a2cc95301"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_all_elements_same </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize all grid elements to the same value. </p>
<p>Sets all allocated elements, including those in the domain and padding area to the same specified value. </p><dl class="section note"><dt>Note</dt><dd>The parameter is a double-precision floating-point value, but it will be converted to single-precision if <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a> returns 4. </dd>
<dd>
If storage has not been allocated via <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a>, this will have no effect. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>All elements will be set to this. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5378027cf69c0456b56458ef215e3404"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::set_elements_in_slice_same </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_indices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize grid elements within specified subset of the grid to the same value. </p>
<p>Sets all elements from <code>first_indices</code> to <code>last_indices</code> in each dimension to the specified value. Provide indices in two lists in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension. If storage has not been allocated for this grid, this will have no effect. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements set. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>All elements in the slice will be set to this. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_indices</td><td>List of initial indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_indices</td><td>List of final indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strict_indices</td><td>If true, indices must be within domain or padding. If false, only elements within the allocation of this grid will be set, and elements outside will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1c07955bb53c6ee8775dc1b1f459015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::set_elements_in_slice </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set grid elements within specified subset of the grid from values in a buffer. </p>
<p>Reads elements from consecutive memory locations, starting at <code>buffer_ptr</code> and writes them from <code>first_indices</code> to <code>last_indices</code> in each dimension. Indices in the buffer progress in row-major order. The buffer pointed to must contain either 4 or 8 byte FP values per element in the subset, depending on the FP precision of the solution. The buffer pointed to must contain the number of FP values in the specified slice, where each FP value is the size of <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a>. Since the writes proceed in row-major order, the last index is "unit-stride" in the buffer. Provide indices in two lists in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. Indices are relative to the <em>overall</em> problem domain. Index values must fall within the allocated space as returned by <a class="el" href="classyask_1_1yk__grid.html#a4f747153ff9c3f67575754a0bfafedc1" title="[Advanced] Get the first accessible index in this grid in this rank in the specified dimension...">get_first_rank_alloc_index()</a> and <a class="el" href="classyask_1_1yk__grid.html#acfb59507b9509f99d33a5cf72d997be7" title="[Advanced] Get the last accessible index in this grid in this rank in the specified dimension...">get_last_rank_alloc_index()</a> for each dimension. If storage has not been allocated for this grid, this will have no effect. </p><dl class="section return"><dt>Returns</dt><dd>Number of elements written. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer_ptr</td><td>Pointer to buffer where values will be read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_indices</td><td>List of initial indices, one for each grid dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last_indices</td><td>List of final indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3615b3324d33e65f229254c3d567b15b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_grid::format_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the indices for pretty-printing. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. </p><dl class="section return"><dt>Returns</dt><dd>A string containing the grid name and the index values. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a695ec7b3053af2b1af4e97991e0b1c1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string yask::yk_grid::format_indices </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format the indices for pretty-printing. </p>
<p>Provide indices in a list in the same order returned by <a class="el" href="classyask_1_1yk__grid.html#a3192f8e120de61ad510ecc82ea2a0eb4" title="Get all the dimensions in this grid. ">get_dim_names()</a>. </p><dl class="section note"><dt>Note</dt><dd>This version is not available (or needed) in SWIG-based APIs, e.g., Python. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing the grid name and the index values. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>List of indices, one for each grid dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76951eeaa5081676dde0ab9e6f57433a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_grid::set_numa_preferred </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numa_node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the default preferred NUMA node on which to allocate data. </p>
<p>This value is used when allocating data for this grid. Thus, the desired NUMA policy must be set before calling alloc_data() or <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a>. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if NUMA preference was set; <code>false</code> if NUMA preferences are not enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numa_node</td><td>Preferred NUMA node. See <a class="el" href="classyask_1_1yk__solution.html#ac8bde8dfc73219cec84ad3033faabb90" title="[Advanced] Set the default preferred NUMA node on which to allocate data. ">yk_solution::set_default_numa_preferred()</a> for other options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c1fbb741b6bb45aed06fb3fac65fb4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int yask::yk_grid::get_numa_preferred </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the default preferred NUMA node on which to allocate data. </p>
<dl class="section return"><dt>Returns</dt><dd>Current setting of preferred NUMA node for this grid. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ba5bc68fb89ff0f58e1adde054707ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_left_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum left padding in the specified dimension. </p>
<p>This sets the minimum number of elements in this grid in the left padding area. This padding area can be used for required halo areas. This function may be useful in the unusual case where the final halo size is unknown when the storage is allocated.</p>
<p>Call <a class="el" href="classyask_1_1yk__grid.html#aacd190b453a8c28d556bcf756da0c650" title="Get the left padding in the specified dimension. ">get_left_pad_size()</a> to determine the actual padding size for the grid. See additional behavior related to setting pad size under <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of grid padding for all grids. ">yk_solution::set_min_pad_size()</a>. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a> for information on grid sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Minimum number of elements to allocate before the domain size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33e38a33f098cc29c50abfe8dcfe0c38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_right_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum right padding in the specified dimension. </p>
<p>This sets the minimum number of elements in this grid in the right padding area. This padding area can be used for required halo areas. This function may be useful in the unusual case where the final halo size is unknown when the storage is allocated.</p>
<p>Call <a class="el" href="classyask_1_1yk__grid.html#ae67d6e1269d8c334edd715971f9a76dc" title="Get the right padding in the specified dimension. ">get_right_pad_size()</a> to determine the actual padding size for the grid. See additional behavior related to setting pad size under <a class="el" href="classyask_1_1yk__solution.html#ab3bd7e95ea13631954d92a638badfb2d" title="[Advanced] Set the minimum amount of grid padding for all grids. ">yk_solution::set_min_pad_size()</a>. See the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a> for information on grid sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Minimum number of elements to allocate after the domain size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5dcbd72d78bcd819a44237feb95c5ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_min_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the minimum padding in the specified dimension. </p>
<p>Shorthand for calling <a class="el" href="classyask_1_1yk__grid.html#a9ba5bc68fb89ff0f58e1adde054707ef" title="[Advanced] Set the minimum left padding in the specified dimension. ">set_left_min_pad_size()</a> and <a class="el" href="classyask_1_1yk__grid.html#a33e38a33f098cc29c50abfe8dcfe0c38" title="[Advanced] Set the minimum right padding in the specified dimension. ">set_right_min_pad_size()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Minimum number of elements to allocate before and after the domain size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac687166a85bee225d8aa14f44bbfa6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_left_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the left halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler, but this function allows you to override that value. If the left halo is set to a value larger than the left padding size, the left padding size will be automatically increase to accomodate it. </p><dl class="section note"><dt>Note</dt><dd>After data storage has been allocated, the left halo size can only be set to a value less than or equal to the left padding size in the given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements in the left halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa47ac53814983d98603279bcab57ad3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_right_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the right halo size in the specified dimension. </p>
<p>This value is typically set by the stencil compiler, but this function allows you to override that value. If the right halo is set to a value larger than the right padding size, the right padding size will be automatically increase to accomodate it. </p><dl class="section note"><dt>Note</dt><dd>After data storage has been allocated, the right halo size can only be set to a value less than or equal to the right padding size in the given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements in the right halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae21feb2f51ded1b7a8f7fdb1591be263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the left and right halo sizes in the specified dimension. </p>
<p>Alias for set_left_halo_size(dim, size); set_right_halo_size(dim, size). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements in the halo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f9c2e794661bbffc72b9648646b5456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_alloc_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the number of elements to allocate in the specified dimension. </p>
<p>This setting is only allowed in the step dimension. Typically, the allocation in the step dimension is determined by the stencil compiler, but this function allows you to override that value. Allocations in other dimensions should be set indirectly via the domain and padding sizes. The allocation size cannot be changed after data storage has been allocated for this grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to set. Must <em>not</em> be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to allocate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3485a6583f0b4c576b4db40d960aad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::set_first_misc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a>&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Set the first index of a specified miscellaneous dimension. </p>
<p>Sets the first allowed index in a non-step and non-domain dimension. After calling this function, the last allowed index will be the first index as set by this function plus the allocation size set by <a class="el" href="classyask_1_1yk__grid.html#a9f9c2e794661bbffc72b9648646b5456" title="[Advanced] Set the number of elements to allocate in the specified dimension. ">set_alloc_size()</a> minus one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#adef99aeda1db20563066c00a66533fbc" title="Get all the miscellaneous dimension names. ">yk_solution::get_misc_dim_names()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>New value for first index. May be negative. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f747153ff9c3f67575754a0bfafedc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_first_rank_alloc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the first accessible index in this grid in this rank in the specified dimension. </p>
<p>This returns the first <em>overall</em> index allowed in this grid. This element may be in the domain, left halo, or extra left padding area. This function is only for checking the legality of an index. </p><dl class="section return"><dt>Returns</dt><dd>First allowed index in this grid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfb59507b9509f99d33a5cf72d997be7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_last_rank_alloc_index </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get the last accessible index in this grid in this rank in the specified dimension. </p>
<p>This returns the last <em>overall</em> index allowed in this grid. This element may be in the domain, right halo, or extra right padding area. This function is only for checking the legality of an index. </p><dl class="section return"><dt>Returns</dt><dd>Last allowed index in this grid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a285627d34759f233aa3e054333e7c60e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_grid::is_storage_allocated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine whether storage has been allocated. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if storage has been allocated, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab51a768ecd909e73ed232360079c1525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_num_storage_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine size of raw storage in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Minimum number of bytes required for storage given the current domain size and padding settings. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a8bb55d8708ecf1e9b332bf96470a4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_num_storage_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determine size of raw storage in elements. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classyask_1_1yk__grid.html#ab51a768ecd909e73ed232360079c1525" title="[Advanced] Determine size of raw storage in bytes. ">get_num_storage_bytes()</a> / <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution.get_element_bytes()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a054d222630dc987cd5b960fcbfc46274"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::alloc_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Explicitly allocate data-storage memory for this grid. </p>
<p>Amount of allocation is calculated based on domain, padding, and step-dimension allocation sizes. Any pre-existing storage will be released before allocation as via <a class="el" href="classyask_1_1yk__grid.html#a516c37b0cc9890fa00012f835c030352" title="[Advanced] Explicitly release any allocated data-storage for this grid. ">release_storage()</a>. See allocation options in the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a>. </p>

</div>
</div>
<a class="anchor" id="a516c37b0cc9890fa00012f835c030352"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::release_storage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Explicitly release any allocated data-storage for this grid. </p>
<p>This will release storage allocated via any of the options described in the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a>. If the data was shared between two or more grids, the data will be retained by the remaining grids. </p>

</div>
</div>
<a class="anchor" id="af0db2cbe2a067e301c843ea95dec5c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool yask::yk_grid::is_storage_layout_identical </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Determines whether storage layout is the same as another grid. </p>
<p>In order for the storage layout to be identical, the following must be the same:</p><ul>
<li>Number of dimensions.</li>
<li>Name of each dimension, in the same order.</li>
<li>Allocation size in each dimension.</li>
<li>Rank domain size in each domain dimension.</li>
<li>Padding size in each domain dimension.</li>
</ul>
<p>The following do not have to be identical:</p><ul>
<li>Halo size.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if storage for this grid has the same layout as <code>other</code> or <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d971de562e05adae61c4495650cd93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void yask::yk_grid::share_storage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__yk.html#gae5dac876afa6218bf6477830915800f2">yk_grid_ptr</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Use existing data-storage from specified grid. </p>
<p>This is an alternative to allocating data storage via <a class="el" href="classyask_1_1yk__solution.html#aa0edfde033c251e3f8d2d184a682d4cb" title="Prepare the solution for stencil application. ">yk_solution::prepare_solution()</a> or <a class="el" href="classyask_1_1yk__grid.html#a054d222630dc987cd5b960fcbfc46274" title="[Advanced] Explicitly allocate data-storage memory for this grid. ">alloc_storage()</a>. In this case, data from a grid in this or another solution will be shared with this grid. In order to successfully share storage, the following conditions must hold:</p><ul>
<li>The source grid must already have storage allocated.</li>
<li>The two grids must have the same dimensions in the same order.</li>
<li>The two grids must have the same domain sizes in all domain dimensions.</li>
<li>The two grids must have the same allocation sizes in non-domain dimensions.</li>
<li>The required padding size of this grid must be less than or equal to the actual padding size of the source grid in all domain dimensions. The required padding size of this grid will be equal to or greater than its halo size. It is not strictly necessary that the two grids have the same halo sizes, but that is a sufficient condition.</li>
</ul>
<p>Any pre-existing storage will be released before allocation as via <a class="el" href="classyask_1_1yk__grid.html#a516c37b0cc9890fa00012f835c030352" title="[Advanced] Explicitly release any allocated data-storage for this grid. ">release_storage()</a>. The padding size(s) of this grid will be set to that of the source grid. After calling <a class="el" href="classyask_1_1yk__grid.html#af7d971de562e05adae61c4495650cd93" title="[Advanced] Use existing data-storage from specified grid. ">share_storage()</a>, changes in one grid via set_all_elements() or <a class="el" href="classyask_1_1yk__grid.html#a9f93ff6dc86a5161a9a5b642e8a82698" title="Set the value of one element in this grid. ">set_element()</a> will be visible in the other grid.</p>
<p>See allocation options and more information about grid sizes in the "Detailed Description" for <a class="el" href="classyask_1_1yk__grid.html">yk_grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>Grid from which storage will be shared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeff12df3c3582a022fdf6bfde6626806"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* yask::yk_grid::get_raw_storage_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Advanced]</b> Get pointer to raw data storage buffer. </p>
<p>The following assumptions about the contents of data are safe:</p><ul>
<li>Each FP element starts at a number of bytes from the beginning of the buffer which is a multiple of <a class="el" href="classyask_1_1yk__solution.html#a0097b91ea92fbe781ba4e8b6746bd665" title="Get the floating-point precision size. ">yk_solution::get_element_bytes()</a>.</li>
<li>All the FP elements will be located within <a class="el" href="classyask_1_1yk__grid.html#ab51a768ecd909e73ed232360079c1525" title="[Advanced] Determine size of raw storage in bytes. ">get_num_storage_bytes()</a> bytes from the beginning of the buffer.</li>
<li>A call to <a class="el" href="classyask_1_1yk__grid.html#a9f45864a94cad82e0b54df6a2cc95301" title="Initialize all grid elements to the same value. ">set_all_elements_same()</a> will initialize all elements within <a class="el" href="classyask_1_1yk__grid.html#ab51a768ecd909e73ed232360079c1525" title="[Advanced] Determine size of raw storage in bytes. ">get_num_storage_bytes()</a> bytes from the beginning of the buffer.</li>
<li>If <a class="el" href="classyask_1_1yk__grid.html#af0db2cbe2a067e301c843ea95dec5c79" title="[Advanced] Determines whether storage layout is the same as another grid. ">is_storage_layout_identical()</a> returns <code>true</code> between this and some other grid, any given element index applied to both grids will refer to an element at the same offset into their respective data buffers.</li>
</ul>
<p>Thus,</p><ul>
<li>You can perform element-wise unary mathematical operations on all elements of a grid via its raw buffer, e.g., add some constant value to all elements.</li>
<li>If the layouts of two grids are identical, you can use their raw buffers to copy or compare the grid contents for equality or perform element-wise binary mathematical operations on them, e.g., add all elements from one grid to another.</li>
</ul>
<p>The following assumptions are not safe:</p><ul>
<li>Any expectations regarding the relationship between an element index and that element's offset from the beginning of the buffer such as row-major or column-major layout.</li>
<li>All elements in the buffer are part of the rank domain or halo.</li>
</ul>
<p>Thus,</p><ul>
<li>You should not perform any operations dependent on the logical indices of any element via raw buffer, e.g., matrix multiply.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Pointer to raw data storage if <a class="el" href="classyask_1_1yk__grid.html#a285627d34759f233aa3e054333e7c60e" title="[Advanced] Determine whether storage has been allocated. ">is_storage_allocated()</a> returns <code>true</code> or NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a735b2d2efe08af9f15275a8139e22079"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_halo_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Deprecated]</b> Get the left halo size in the specified dimension. </p>
<p>Alias for get_left_halo_size(dim, size). </p><dl class="section return"><dt>Returns</dt><dd>Elements in halo in given dimension before the domain. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d5576bdf5a8dff49f467430c2103661"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Deprecated]</b> Get the left padding in the specified dimension. </p>
<p>Alias for get_left_pad_size(dim). </p><dl class="section return"><dt>Returns</dt><dd>Elements in left padding in given dimension. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec439943d3e07f05703c2895989c18b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__yask.html#ga3820f8c6b5f6a92c0df31746b7d2891b">idx_t</a> yask::yk_grid::get_extra_pad_size </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><b>[Deprecated]</b> Get the extra left padding in the specified dimension. </p>
<p>Alias for get_extra_left_pad_size(dim). </p><dl class="section return"><dt>Returns</dt><dd>Elements in padding in given dimension before the left halo area. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Name of dimension to get. Must be one of the names from <a class="el" href="classyask_1_1yk__solution.html#a163d10690a6b636b2929e9a82ac2737b" title="Get all the domain dimension names. ">yk_solution::get_domain_dim_names()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="yk__grid__api_8hpp_source.html">yk_grid_api.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
